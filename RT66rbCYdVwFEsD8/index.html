<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog_v0/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog_v0/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog_v0/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog_v0/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/blog_v0/css/main.css">


<link rel="stylesheet" href="/blog_v0/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/blog_v0/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第6部分——动态规划。这里把有代表性的题目发出来，共计56道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之动态规划">
<meta property="og:url" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第6部分——动态规划。这里把有代表性的题目发出来，共计56道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/minpath.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/image-20210428181037785.png">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/image-20210428181149058.png">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/1601009732-AqPWoe-file_1601009732619.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/rob1-tree.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/rob2-tree.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/486_fig1.png">
<meta property="article:published_time" content="2021-05-01T13:35:42.000Z">
<meta property="article:modified_time" content="2021-05-01T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/minpath.jpg">

<link rel="canonical" href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之动态规划 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog_v0/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog_v0/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog_v0/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog_v0/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog_v0/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog_v0/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之动态规划
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-01 21:35:42" itemprop="dateCreated datePublished" datetime="2021-05-01T21:35:42+08:00">2021-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog_v0/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>81k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:13</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>6</code>部分——动态规划。这里把有代表性的题目发出来，共计<code>56</code>道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
<a id="more"></a>


<h5 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum</a></h5><blockquote>
<p>给定一个<code>m × n</code>的网格，其中填充了非负数，请找到从左上到右下的路径，这将沿其路径的所有数字的总和最小化。</p>
<p>注意：您只能在任何时间点向下或向右移动。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<p><strong>Example:</strong></p>
<p><img src="minpath.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示从起点走到第 i 行, 第 j 列的最小路径和</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写可避免循环内每次的判断语句, 效率提升那么一丢丢</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">72. Edit Distance</a></h5><blockquote>
<p>  Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>
<p>  You have the following three operations permitted on a word:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (insert &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说, 解决字符串的动态规划问题, 是用两个指针 i, j 分别指向两个字符串的尾</span></span><br><span class="line"><span class="comment">// 一步一步向前走, 缩小问题的规模</span></span><br><span class="line"><span class="comment">// 如果我们定义一个 dp 函数 dp(i, j)</span></span><br><span class="line"><span class="comment">// 表示将 word1[0, i] 变为 word2[0, j] 的最小编辑距离的话</span></span><br><span class="line"><span class="comment">// 那么我们要求的就是 dp(word1.size() - 1, word2.size() - 1)</span></span><br><span class="line"><span class="comment">// 那么 dp(i, j) 怎么求呢？</span></span><br><span class="line"><span class="comment">// 考虑之前的状态, 共有 dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1) 三种</span></span><br><span class="line"><span class="comment">// 在编辑 word1 的第 i + 1 个字符时</span></span><br><span class="line"><span class="comment">// 1. 如果 word1[i] == word2[j], 那么直接跳过即可, dp(i, j) = dp(i - 1, j - 1)</span></span><br><span class="line"><span class="comment">// 2. 如果 word1[i] != word2[j] 我们有三种选择</span></span><br><span class="line"><span class="comment">// - 插入一个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i, j - 1) + 1</span></span><br><span class="line"><span class="comment">// - 删除这个字符, word2[j] 没有得到匹配, 那么 dp(i, j) = dp(i - 1, j) + 1</span></span><br><span class="line"><span class="comment">// - 替换这个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i - 1, j - 1) + 1</span></span><br><span class="line"><span class="comment">// 要求最小编辑距离的话, 这三种都试一下, 取最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面相当于暴力解法, 把每一个操作都试一遍取最小值</span></span><br><span class="line"><span class="comment">// 会出现非常多的重叠子问题, 因此需要用备忘录优化一下</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp(word1, word2, word1.size() - <span class="number">1</span>, word2.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">string</span>&amp; word1, <span class="built_in">string</span>&amp; word2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 如果 word1 走到头了, word2 没有, 那么只能插入 word2 剩下的所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果 word2 走到头了, word1 没有, 那么只能删除 word1 剩下的所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> key = to_string(i) + <span class="string">","</span> + to_string(j);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    <span class="keyword">if</span>(word1[i] == word2[j])</span><br><span class="line">        memo[key] = dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        memo[key] = <span class="number">1</span> + min(&#123;dp(word1, word2, i - <span class="number">1</span>, j),</span><br><span class="line">                             dp(word1, word2, i, j - <span class="number">1</span>),</span><br><span class="line">                             dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>)&#125;);</span><br><span class="line">    <span class="keyword">return</span> memo[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 dp table</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size();</span><br><span class="line">    <span class="keyword">int</span> n = word2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + min(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>  子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组<code>[0,3,1,6,2,2,7]</code>的子序列。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>  <strong>Follow up:</strong></p>
<ul>
<li>Could you come up with the <code>O(n2)</code> solution?</li>
<li>Could you improve it to <code>O(n log(n))</code> time complexity?</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line"><span class="comment">// 要求的目标为 dp 数组中的最大值</span></span><br><span class="line"><span class="comment">// base case 以 nums[i] 结尾的最长递增子序列至少要包含它自己 dp[0..] = 1</span></span><br><span class="line"><span class="comment">// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[j] &lt; nums[i]</span></span><br><span class="line"><span class="comment">// 就是在前面找到结尾的比 nums[i] 小的子序列, 把 nums[i] 接到后面, 长度加 1 即可</span></span><br><span class="line"><span class="comment">// 可能有很多个满足条件的接法, 选择长度最大的接法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = *max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 既然题目提示我们这题的时间复杂度可以优化到 O(nlogn)</span></span><br><span class="line"><span class="comment">// logn 的复杂度只有二分法能办到了</span></span><br><span class="line"><span class="comment">// 我们把这些数分成许多堆, 按照下面定义的规则:</span></span><br><span class="line"><span class="comment">// 1. 依次从数组中拿出一个数, 首先第一个数就放在第 1 个堆就行</span></span><br><span class="line"><span class="comment">// 2. 之后每次取出的数必须放在所有堆顶的不小于它的数上面</span></span><br><span class="line"><span class="comment">// 3. 如果有多个堆顶的数都不小于它, 就放在最靠左边的堆上面</span></span><br><span class="line"><span class="comment">// 4. 如果没有这样的堆, 就从右边新起一个堆放</span></span><br><span class="line"><span class="comment">// 这个规则的限制下, 所有堆顶的元素从左到右始终都是有序的</span></span><br><span class="line"><span class="comment">// 这样我们就可以应用二分搜索, 来找第 1 个不小于待放数的堆了</span></span><br><span class="line"><span class="comment">// 那么这和我们的问题: 寻找最长递增子序列有什么关系呢？</span></span><br><span class="line"><span class="comment">// 可以证明, 最长递增子序列就是堆的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pilesTop;</span><br><span class="line">    <span class="comment">// 最多分了 n 个堆, 我们提前分配空间提升效率</span></span><br><span class="line">    pilesTop.reserve(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 寻找左边界二分搜索</span></span><br><span class="line">        <span class="keyword">auto</span> left = lower_bound(pilesTop.begin(), pilesTop.end(), nums[i]);</span><br><span class="line">        <span class="comment">// 如果没有合适的堆, 自己单放</span></span><br><span class="line">        <span class="keyword">if</span>(left == pilesTop.end())</span><br><span class="line">            pilesTop.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 否则, 放堆顶上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *left = nums[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pilesTop.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="354-Russian-Doll-Envelopes"><a href="#354-Russian-Doll-Envelopes" class="headerlink" title="354. Russian Doll Envelopes"></a><a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. Russian Doll Envelopes</a></h5><blockquote>
<p>  给你一个二维整数数组<code>envelopes</code>，其中<code>envelopes[i] = [wi, hi]</code>，表示第<code>i</code>个信封的宽度和高度。</p>
<p>  当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>  请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p>  注意：不允许旋转信封。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: envelopes &#x3D; [[1,1],[1,1],[1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照信封的宽度递增排序, 宽度相等的信封按高度递减排序</span></span><br><span class="line"><span class="comment">// 最大嵌套信封数就是高度序列的最长递增子序列</span></span><br><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(envelopes.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = *max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样的使用二分搜索解法提升效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; piles;</span><br><span class="line">    piles.reserve(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(piles.begin(), piles.end(), nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == piles.end())</span><br><span class="line">            piles.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *it = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> piles.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum</a></h5><blockquote>
<p>  给定一个非负整数数组，<code>a1, a2, ..., an</code>和一个目标数<code>S</code>。现在你有两个符号<code>+</code>和<code>-</code>。对于数组中的任意一个整数，你都可以从<code>+</code>或<code>-</code>中选择一个符号添加在前面。</p>
<p>  返回可以使最终数组和为目标数<code>S</code>的所有添加符号的方法数。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这道题虽然通常想到的都是 dfs 的方法</span></span><br><span class="line"><span class="comment">// 现在让我们再转化一下思路, 看它和动态规划有什么关系</span></span><br><span class="line"><span class="comment">// 数组中的数都是非负数, 把所有数得和表示为 sums</span></span><br><span class="line"><span class="comment">// 我们把前面加正号的数的和 表示为 sumA, 把前面加负号的数的和 表示为 sumB</span></span><br><span class="line"><span class="comment">// 有 sumA - sumB = target</span></span><br><span class="line"><span class="comment">// 移项得 sumA = target + sumB</span></span><br><span class="line"><span class="comment">// 两边加上 sumA 有 sumA + sumA = target + sumA + sumB = target + sums</span></span><br><span class="line"><span class="comment">// 最后 sumA = (target + sums) / 2  = newTarget右边都是已知的</span></span><br><span class="line"><span class="comment">// 也就是说我们把问题转化为了</span></span><br><span class="line"><span class="comment">// 从这些数中选出一个子集, 问我们有多少种选法可使得子集的和等于目标数</span></span><br><span class="line"><span class="comment">// 换种表达方式, 我们把目标数表示为一个背包的载重量</span></span><br><span class="line"><span class="comment">// 数组中的值为一个个石头的重量, 问我们有多少种装法可以把背包装满</span></span><br><span class="line"><span class="comment">// 这是动态规划中典型的背包问题</span></span><br><span class="line"><span class="comment">// 首先在装石头的过程中, 问题中的状态和选择有: 状态就是背包的可载重量和可选择的石头序列</span></span><br><span class="line"><span class="comment">// 选择就是装还是不装</span></span><br><span class="line"><span class="comment">// 由于有两个状态, 所以我们定义一个二维 dp 数组</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示在前 i 个石头中, 背包的可载重量为 j 时, 有多少种装法</span></span><br><span class="line"><span class="comment">// 那么当 i = 0 时, 没有石头, 装法为 0</span></span><br><span class="line"><span class="comment">// 当 j = 0 时, 背包的可载重量为 0 时, 只有 1 种装法, 就是一个也不装</span></span><br><span class="line"><span class="comment">// 那么状态转移方程怎么写呢?</span></span><br><span class="line"><span class="comment">// 对于可选择前 i 个石头, 可载重量为 j 时</span></span><br><span class="line"><span class="comment">// 1. 如果第 i 个石头不装, 那么 dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 如果第 i 个石头装, 那么 dp[i][j] = dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 它们都取决于上一次装的情况, 两种情况要加起来</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 我们最终要求的目标就是 dp[n][m], 其中 n 表示给定数组的长度, m 表示新目标和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 问题转化</span></span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果总和都小于目标和(表示全加正号)或者 sum + target 为奇数(表示 sumA 都不是个整数)</span></span><br><span class="line">    <span class="keyword">if</span>(sum &lt; target || ((sum + target) &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> newTarget = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义 dp 数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(newTarget + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 注意 dp[0][0] 也是 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= newTarget; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.size()][newTarget];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="91-Decode-Ways、-639-Decode-Ways-II"><a href="#91-Decode-Ways、-639-Decode-Ways-II" class="headerlink" title="91. Decode Ways、 639. Decode Ways II"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways</a>、 <a href="https://leetcode.com/problems/decode-ways-ii/" target="_blank" rel="noopener">639. Decode Ways II</a></h5><blockquote>
<p>  一条包含字母<code>A - Z</code>的消息通过以下映射进行了编码：</p>
<p>  <code>&#39;A&#39; -&gt; 1</code><br>  <code>&#39;B&#39; -&gt; 2</code><br>      …<br>  <code>&#39;Z&#39; -&gt; 26</code><br>  要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code>可以映射为：</p>
<p>  <code>&quot;AAJF&quot;</code>，将消息分组为<code>(1 1 10 6)</code><br>  <code>&quot;KJF&quot;</code>，将消息分组为<code>(11 10 6)</code><br>  注意，消息不能分组为<code>(1 11 06)</code>，因为<code>&quot;06&quot;</code>不能映射为<code>&quot;F&quot;</code>，这是由于<code>&quot;6&quot;</code>和<code>&quot;06&quot;</code>在映射中并不等价。</p>
<p>  给你一个只含数字的非空字符串<code>s</code>，请计算并返回解码方法的总数 。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;0&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no character that is mapped to a number starting with 0.</span><br><span class="line">The only valid mappings with 0 are &#39;J&#39; -&gt; &quot;10&quot; and &#39;T&#39; -&gt; &quot;20&quot;, neither of which start with 0.</span><br><span class="line">Hence, there are no valid ways to decode this since all digits need to be mapped.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> contains only digits and may contain leading zero(s).</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case 前两个字符组成的串单放用</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">'0'</span>) dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单放</span></span><br><span class="line">        <span class="keyword">int</span> num = stoi(s[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">9</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 拼着放</span></span><br><span class="line">        num = stoi(s.substr(i - <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="516-Longest-Palindromic-Subsequence"><a href="#516-Longest-Palindromic-Subsequence" class="headerlink" title="516. Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence</a></h5><blockquote>
<p>  给定一个字符串<code>s</code>，找到其中最长的回文子序列，并返回该序列的长度。可以假设<code>s</code>的最大长度为<code>1000</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbab&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One possible longest palindromic subsequence is &quot;bb&quot;.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示子串 s[i..j] 中的最长回文子序列</span></span><br><span class="line"><span class="comment">// if s[i] == s[j]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = dp[i + 1][j - 1] + 2</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[0][n - 1]</span></span><br><span class="line"><span class="comment">// 显然 i == j 时 dp[i][j] = 1, i &gt; j 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1143-Longest-Common-Subsequence"><a href="#1143-Longest-Common-Subsequence" class="headerlink" title="1143. Longest Common Subsequence"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence</a></h5><blockquote>
<p>  给定两个字符串<code>text1</code>和<code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回<code>0</code>。</p>
<p>  一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>  例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的子序列，但<code>&quot;aec&quot;</code>不是<code>&quot;abcde&quot;</code>的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">// if text1[i] == text1[j]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = 1 + dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 || j == 0 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="583-Delete-Operation-for-Two-Strings"><a href="#583-Delete-Operation-for-Two-Strings" class="headerlink" title="583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. Delete Operation for Two Strings</a></h5><blockquote>
<p>  Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong> required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p>
<p>  In one <strong>step</strong>, you can delete exactly one character in either string.</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;sea&quot;, word2 &#x3D; &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;leetcode&quot;, word2 &#x3D; &quot;etco&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看出来, 一番删除操作之后剩下的字符串就是它们的最长公共子序列</span></span><br><span class="line"><span class="comment">// 所以就相当于问删除了多少字符后可以变成最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcs = longestCommonSubsequence(word1, word2);</span><br><span class="line">    <span class="keyword">return</span> word1.size() - lcs + word2.size() - lcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">// if text1[i] == text1[j]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = 1 + dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 || j == 0 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><a href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings" class="headerlink" title="712. Minimum ASCII Delete Sum for Two Strings"></a><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. Minimum ASCII Delete Sum for Two Strings</a></h5><blockquote>
<p>  给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的<code>ASCII</code>值的最小和。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;</span><br><span class="line">Output: 231</span><br><span class="line">Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.</span><br><span class="line">Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.</span><br><span class="line">At the end, both strings are equal, and 115 + 116 &#x3D; 231 is the minimum sum possible to achieve this.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;delete&quot;, s2 &#x3D; &quot;leet&quot;</span><br><span class="line">Output: 403</span><br><span class="line">Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,</span><br><span class="line">adds 100[d]+101[e]+101[e] to the sum.  Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.</span><br><span class="line">At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 &#x3D; 403.</span><br><span class="line">If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.</span><br></pre></td></tr></table></figure>

<p>  <strong>Note:</strong></p>
<p>  <code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</p>
<p>  All elements of each string will have an ASCII value in <code>[97, 122]</code>.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和 LCS 的思路有些许相似之处</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示把 s1[0..i-1] 和 s2[0..j-1] 变相同所删除字符的最小和</span></span><br><span class="line"><span class="comment">// if s1[i - 1] == s2[j - 1]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1])</span></span><br><span class="line"><span class="comment">// 我们要求的目标是 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时 dp[i][j] = sum(s2[0..j-1])</span></span><br><span class="line"><span class="comment">//     j == 0 时 dp[i][j] = sum(s1[0..i-1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.size();</span><br><span class="line">    <span class="keyword">int</span> n = s2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = min(dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a><a href="https://leetcode.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. Largest Divisible Subset</a></h5><blockquote>
<p>  给你一个由无重复正整数组成的集合<code>nums</code>，请你找出并返回其中最大的整除子集<code>answer</code>，子集中每一元素对<code>(answer[i], answer[j])</code>都应当满足：</p>
<ul>
<li><p><code>answer[i] % answer[j] == 0</code>，或<code>answer[j] % answer[i] == 0</code></p>
<p>如果存在多个有效解子集，返回其中任何一个均可。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: [1,3] is also accepted.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,4,8]</span><br><span class="line">Output: [1,2,4,8]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题要先把数组按照升序排列, 排完序之后就是求最长倍增子序列</span></span><br><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的最长倍增子序列的长度</span></span><br><span class="line"><span class="comment">// 要求的目标为 dp 数组中的最大值</span></span><br><span class="line"><span class="comment">// base case 以 nums[i] 结尾的最长倍增子序列至少要包含它自己 dp[0..] = 1</span></span><br><span class="line"><span class="comment">// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[i] % nums[j] == 0</span></span><br><span class="line"><span class="comment">// 就是在前面找到可以被 nums[i] 整除的子序列, 把 nums[i] 接到后面, 长度加 1 即可</span></span><br><span class="line"><span class="comment">// 可能有很多个满足条件的接法, 选择长度最大的接法</span></span><br><span class="line"><span class="comment">// 但是由于这题不是让我们输出最长倍增子序列的个数, 而是把它们作为数组输出</span></span><br><span class="line"><span class="comment">// 所以 dp 数组里存的不止是最大个数, 还有它上一个数的索引</span></span><br><span class="line"><span class="comment">// 这样最后通过 dp 数组中的最大值, 找到前一个数的索引, 然后反推前面所有的数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// &#123;最长倍增子序列个数, 上一个数的索引&#125;</span></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; dp(n, &#123;1, -1&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[i].first &lt; dp[j].first + <span class="number">1</span>)</span><br><span class="line">                dp[i] = &#123;dp[j].first + <span class="number">1</span>, j&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.push_back(nums[distance(dp.begin(), it)]);</span><br><span class="line">    <span class="keyword">int</span> index = it-&gt;second;</span><br><span class="line">    <span class="keyword">while</span>(index != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(nums[index]);</span><br><span class="line">        index = dp[index].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a></h5><blockquote>
<p>  给定一个数组<code>prices</code>，它的第<code>i</code>个元素<code>prices[i]</code>表示一支给定股票第<code>i</code>天的价格。</p>
<p>  你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>  返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接贪心算法</span></span><br><span class="line"><span class="comment">// 要在价格最低点买, 价格最高点卖掉</span></span><br><span class="line"><span class="comment">// 从前往后遍历, 记录史最低点</span></span><br><span class="line"><span class="comment">// 今天卖掉的利润等于今天的价格减去历史最低点的价格</span></span><br><span class="line"><span class="comment">// 每一天都考虑是否卖掉, 如果今天卖掉比之前卖掉得到的利润大就卖掉</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">int</span> minPrice = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="comment">// 如果今天的价格比历史最低点价格还低, 更新最低价格</span></span><br><span class="line">    	<span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">    	<span class="comment">// 否则, 如果今天卖出的话比之前卖出得到的利润大, 就卖出</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - minPrice &gt; maxProfit)</span><br><span class="line">            maxProfit = prices[i] - minPrice;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 但是这种情况下, 【由于只能交易一次】, 你当天才买进的话, 之前的利润肯定是 0, 即 dp[i - 1][0] = 0</span></span><br><span class="line"><span class="comment">// 所以, dp[i][1] = max(dp[i - 1][1], - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></h5><blockquote>
<p>  给定一个数组<code>prices</code>，其中<code>prices[i]</code>是一支给定股票第<code>i</code>天的价格。</p>
<p>  设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e., max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a></h5><blockquote>
<p>  给定一个数组，它的第<code>i</code>个元素是一支给定的股票在第<code>i</code>天的价格。</p>
<p>  设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔交易</strong>。</p>
<p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题就是下一题 k = 2 的情形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">           dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. Best Time to Buy and Sell Stock IV</a></h5><blockquote>
<p>  给定一个整数数组<code>prices</code>，它的第<code>i</code>个元素<code>prices[i]</code>是一支给定的股票在第<code>i</code>天的价格。</p>
<p>  设计一个算法来计算你所能获取的最大利润。你最多可以<strong>完成<code>k</code>笔交易</strong>。</p>
<p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 2) and sell on day 2 (price &#x3D; 4), profit &#x3D; 4-2 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 2) and sell on day 3 (price &#x3D; 6), profit &#x3D; 6-2 &#x3D; 4. Then buy on day 5 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题我们最多可以完成 k 笔交易</span></span><br><span class="line"><span class="comment">// 所以有三个状态 [天数], [交易次数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][j][0] 表示第 i 天没有持有股票, 交易次数为 j 时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][j][1] 表示第 i 天持有股票, 交易次数为 j 时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][j][0] = max(dp[i - 1][j][1] + prices[i - 1], dp[i - 1][j][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票 (买进的时候交易次数加 1)</span></span><br><span class="line"><span class="comment">// dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][k][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][j][0] = 0, dp[0][j][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="comment">// 当 j == 0 时, dp[i][0][0] = 0, dp[i][0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">           dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. Best Time to Buy and Sell Stock with Cooldown</a></h5><blockquote>
<p>  给定一个整数数组，其中第<code>i</code>个元素代表了第<code>i</code>天的股票价格 。</p>
<p>  设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>  你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为<code>1</code>天)。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,0,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: transactions &#x3D; [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限, 但是有冷冻期, 因此买进的时候需要看大前天的状态</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 只能大前天没有持有股票且没有卖出股票, 当天才能买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="comment">// 当 i == 1 时, dp[1][0] = 0, dp[1][1] = -prices[0]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 第 1 天的情况已经知道了, 直接从第 2 天开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h5><blockquote>
<p>给定一个数组<code>prices</code>，其中<code>prices[i]</code>是一支给定股票第<code>i</code>天的价格。非负整数<code>fee</code>表示交易一次股票需要支付的费用。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// 这里选择买进股票时支付手续费, 相当于买进价格升高了呗</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1] - fee)</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV</a></h5><blockquote>
<p>  给你一个由<strong>不同整数</strong>组成的数组<code>nums</code>，和一个目标整数<code>target</code>。请你从<code>nums</code>中找出并返回总和为<code>target</code>的元素组合的个数。</p>
<p>  题目数据保证<strong>答案符合</strong><code>32</code>位整数范围。</p>
<p>  示例 1：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。（这特么就是排列呀！！！）</span><br></pre></td></tr></table></figure>

<p>  示例 2：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9], target &#x3D; 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo.resize(target + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义为凑够和为 target 的组合数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[target] != <span class="number">-1</span>) <span class="keyword">return</span> memo[target];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        res += dfs(nums, target - num);</span><br><span class="line">    memo[target] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题其实并不是组合问题, 而是排列问题</span></span><br><span class="line"><span class="comment">// 组合不关注元素顺序, 排列才关注元素顺序, 而这题关注元素的顺序!</span></span><br><span class="line"><span class="comment">// 状态有 [排列和 target]</span></span><br><span class="line"><span class="comment">// dp[i] 表示组合的和等于 i 时的不同组合个数</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[target]</span></span><br><span class="line"><span class="comment">// 如果我们考虑将 nums[j] 加入组合中去, 并且放在最后的位置</span></span><br><span class="line"><span class="comment">// [[也就是关注排列中的最后一个数是多少]]</span></span><br><span class="line"><span class="comment">// 那么此时 dp[i] 就等于所有的 dp[i - nums[j]] (j = 0, ...) 之和</span></span><br><span class="line"><span class="comment">// dp[0] = 1 表示 1 种空组合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="comment">// dp[i] + dp[i - num] 有可能溢出, 这里为了清晰起见没有考虑</span></span><br><span class="line">            <span class="keyword">if</span>(i - num &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这题还可以将其看作一个爬楼梯问题</span></span><br><span class="line"><span class="comment">// 楼梯的阶数一共为 target, 一次可以走的步数为 nums[i]</span></span><br><span class="line"><span class="comment">// 问你一共有多少种走法 (相当于登上最高阶所走步数的所有排列)</span></span><br><span class="line"><span class="comment">// [[只要关注最后一步走多少阶数就容易写出状态转移方程了]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以看作是完全背包问题</span></span><br><span class="line"><span class="comment">// 背包的容量为 target, 有物品 nums[i] 可以无限选取</span></span><br><span class="line"><span class="comment">// 并且相同的物品选择, 物品选取的顺序不同算是不同的选择</span></span><br><span class="line"><span class="comment">// 问你把背包装满有多少种方法</span></span><br><span class="line"><span class="comment">// 这题为了考虑不同的顺序, 因此外循环遍历背包的容量, 内循环遍历物品</span></span><br><span class="line"><span class="comment">// 对于下题 [换零钱 2] 由于顺序不同也算一种选择, 就要外循环遍历物品, 内循环遍历背包的容量</span></span><br></pre></td></tr></table></figure>

<h5 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change</a></h5><blockquote>
<p>  给定不同面额的硬币<code>coins</code>和一个总金额<code>amount</code>。编写一个函数来计算可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回<code>-1</code>。</p>
<p>  你可以认为每种硬币的数量是无限的。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10^4</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态只有 金额数</span></span><br><span class="line"><span class="comment">// 选择有若干枚硬币</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示凑够金额 i 元的最少硬币数</span></span><br><span class="line"><span class="comment">// dp[i] = min(dp[i - k] + 1) k 为每种硬币的面值</span></span><br><span class="line"><span class="comment">// 目标是求 dp[amount]</span></span><br><span class="line"><span class="comment">// 显然 dp[0] = 0 就是不用任何面值的硬币就凑够了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组中每个值初始化为 amount + 1 表示不可能</span></span><br><span class="line">    <span class="comment">// 因为只使用 1 元硬币最多也就需要 amount 个硬币</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= coin)</span><br><span class="line">            	dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以看成是一个完全背包问题</span></span><br><span class="line"><span class="comment">// 状态有 [使用的硬币] 和 [凑成的总金额]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的最少硬币数</span></span><br><span class="line"><span class="comment">// 对于第 i 枚硬币有使用和不使用两种选择</span></span><br><span class="line"><span class="comment">// 如果不使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j] 继承之前的硬币数</span></span><br><span class="line"><span class="comment">// 如果使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - coins[i - 1]] + 1</span></span><br><span class="line"><span class="comment">// 表示只使用前 i 种硬币凑够 j - coins[i - 1] 的硬币数, 再加上使用的这枚硬币</span></span><br><span class="line"><span class="comment">// 因为要求最少的硬币数, 这两种选择的结果取小值</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);</span></span><br><span class="line"><span class="comment">// 显然 j == 0 时 dp[i][0] = 0 就是不凑就够了, 数量为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.size();</span><br><span class="line">    <span class="comment">// 都初始化为 amount + 1 表示不可能的结果, min 时会排除掉</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, amount + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change 2</a></h5><blockquote>
<p>  给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的<strong>硬币组合数</strong>。假设每一种面额的硬币有无限个。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.size() &lt;= 300</code></li>
<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 5, coins &#x3D; [1,2,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5 &#x3D; 5</span><br><span class="line">5 &#x3D; 2 + 2 + 1</span><br><span class="line">5 &#x3D; 2 + 1 + 1 + 1</span><br><span class="line">5 &#x3D; 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="comment">// 状态有 [使用的硬币] 和 [凑成的总金额]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的组合数</span></span><br><span class="line"><span class="comment">// 对于第 i 枚硬币有使用和不使用两种选择</span></span><br><span class="line"><span class="comment">// 如果不使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j] 继承之前的组合数</span></span><br><span class="line"><span class="comment">// 如果使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - coins[i - 1]] 表示使用前 i 种硬币凑够 j - coins[i - 1] 的组合数</span></span><br><span class="line"><span class="comment">// 因为要求总的组合数, 这两种选择的结果相加</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时 dp[0][j] = 0 不使用任何硬币</span></span><br><span class="line"><span class="comment">//     j == 0 时 dp[i][0] = 1 就是不凑就够了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])</span><br><span class="line">            	dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">474. Ones and Zeroes</a></h5><blockquote>
<p>  给你一个二进制字符串数组<code>strs</code>和两个整数<code>m</code>和<code>n</code>。</p>
<p>  请你找出并返回<code>strs</code>的最大子集的大小，该子集中最多有<code>m</code>个<code>0</code>和<code>n</code>个<code>1</code>。</p>
<p>  如果<code>x</code>的所有元素也是<code>y</code>的元素，集合<code>x</code>是集合<code>y</code>的子集 。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.</span><br><span class="line">Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.</span><br><span class="line">&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The largest subset is &#123;&quot;0&quot;, &quot;1&quot;&#125;, so the answer is 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 600</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> consists only of digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包问题</span></span><br><span class="line"><span class="comment">// 这里有两个背包, 一个装 0, 一个装 1</span></span><br><span class="line"><span class="comment">// 每个物品(串)同时消耗两个背包的容量, 每个物品的价值为 1</span></span><br><span class="line"><span class="comment">// 状态有 [可选择的物品], [背包 0 的容量] 和 [背包 1 的容量]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j][k] 表示只装前 i 个物品, 背包 0 和 1 的容量分别为 j 和 k 时所能装的最大价值</span></span><br><span class="line"><span class="comment">// 对于第 i 个物品 strs[i - 1] 你的选择就是装与不装</span></span><br><span class="line"><span class="comment">// 1. 不装</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j][k]</span></span><br><span class="line"><span class="comment">// 2. 装</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])]</span></span><br><span class="line"><span class="comment">// 因为要求的是最大价值, 那就比较两种选择孰大孰小</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])])</span></span><br><span class="line"><span class="comment">// 显然当 i == 0 时, dp[0][j][k] = 0, 没有物品可以装, 价值只能是 0</span></span><br><span class="line"><span class="comment">//       j == 0 || k == 0 时, dp[0][j][k] = 0, 背包没有容量了价值也是 0</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[sz][m][n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = strs.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(sz + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n  + <span class="number">1</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [zeros, ones] = count_01(strs[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 注意 j 和 k 的起始索引, 有可能物品只消耗其中一种背包的容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; zeros || k &lt; ones)</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                	dp[i][j][k] = max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - zeros][k - ones] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sz][m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; count_01(const string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, n = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) <span class="keyword">if</span>(c == <span class="string">'0'</span>) cnt++;</span><br><span class="line">    <span class="keyword">return</span> &#123;cnt, n - cnt&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break</a></h5><blockquote>
<p>  给定一个非空字符串<code>s</code>和一个包含非空单词的列表<code>wordDict</code>，判定<code>s</code>是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>  说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和背包问题有点类似, 但有不同之处</span></span><br><span class="line"><span class="comment">// 状态有 [可选择的字符]</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示对于前 i 个字符是否有满足条件的划分</span></span><br><span class="line"><span class="comment">// 和背包之处不同在于, 对于第 i 个字符 s[i - 1] 只有一个选择, 就是必须选择</span></span><br><span class="line"><span class="comment">// 这时我们需要将前 i 个字符用索引 j 划分为两部分</span></span><br><span class="line"><span class="comment">// 对于前半部分 s[0..j-1] 可以利用已经算出来的 dp[j]</span></span><br><span class="line"><span class="comment">// 后半部分 s[j..i-1] 需要单独判断是否在单词集合中</span></span><br><span class="line"><span class="comment">// 所以 dp[i] = dp[i] || (dp[j] &amp;&amp; (s[j..i-1] in wordDict)) j 从 0 到 i - 1</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 为了需要, 我们定义空串是有效的</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            dp[i] = dp[i] || (dp[j] &amp;&amp; setting.count(s.substr(j, i - j)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="keyword">return</span> dfs(s, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo.count(s)) <span class="keyword">return</span> memo[s];</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(setting.count(s.substr(<span class="number">0</span>, i)) &amp;&amp; dfs(s.substr(i), setting))</span><br><span class="line">            <span class="keyword">return</span> memo[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> memo[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II</a></h5><blockquote>
<p>  给定一个非空字符串<code>s</code>和一个包含非空单词列表的字典<code>wordDict</code>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p>  说明：</p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
<li><code>1 &lt;= s.size() &lt;= 20</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentences;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    dfs(s, <span class="string">""</span>, setting);</span><br><span class="line">    <span class="keyword">return</span> sentences;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> sentence, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        sentence.pop_back();</span><br><span class="line">        sentences.push_back(sentence);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!setting.count(s.substr(<span class="number">0</span>, i)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(s.substr(i), sentence + s.substr(<span class="number">0</span>, i) + <span class="string">" "</span>, setting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum</a></h5><blockquote>
<p>  Given a <strong>non-empty</strong> array <code>num</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into <strong>two subsets</strong> such that <strong>the sum of elements in both subsets is equal</strong>.</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,5]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为背包问题进行求解</span></span><br><span class="line"><span class="comment">// 我们把数组分成两部分</span></span><br><span class="line"><span class="comment">// 1. sumA = sumB</span></span><br><span class="line"><span class="comment">// 2. sumA + sumB = sum</span></span><br><span class="line"><span class="comment">// 所以有 sumA = sum / 2</span></span><br><span class="line"><span class="comment">// 也就是说现在有一个背包的容量恰好是 sum / 2</span></span><br><span class="line"><span class="comment">// 问我们是否有一种装法恰好装满背包</span></span><br><span class="line"><span class="comment">// 背包问题的状态一般就两个 [可选择的物品] 和 [背包的容量]</span></span><br><span class="line"><span class="comment">// 所以我们定义 dp[i][j] 表示使用前 i 个物品, 背包容量为 j 时是否有一种装法给装满</span></span><br><span class="line"><span class="comment">// 对于第 i 个物品 nums[i - 1] 可以选择装进去和不装进去</span></span><br><span class="line"><span class="comment">// 1. 不装 就要看前 i - 1 个物品能不能装满容量为 j 的背包</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 装 就要看前 i - 1 个物品能不能装满容量为 j - nums[i - 1] 的背包</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 这两种任意一种选择为真的话, 就为真</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][sum/2]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时, dp[0][j] = false, 没有物品装肯定装不满</span></span><br><span class="line"><span class="comment">//     j == 0 时, dp[i][0] = true, 容量为 0 了就是装满了啊</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果 sum 为奇数, 显然不可能</span></span><br><span class="line">    <span class="keyword">if</span>(sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum/<span class="number">2</span> + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="698-Partition-to-K-Equal-Sum-Subsets"><a href="#698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="698. Partition to K Equal Sum Subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">698. Partition to K Equal Sum Subsets</a></h5><blockquote>
<p>  给定一个整数数组<code>nums</code>和一个正整数<code>k</code>，找出是否有可能把这个数组分成<code>k</code>个非空子集，其总和都相等。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,3,2,3,5,2,1], k &#x3D; 4</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4], k &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
<li><code>0 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实上题 416(k = 2) 以及 473(k = 4) 都是这题的特例</span></span><br><span class="line"><span class="comment">// 这题很容易超时, 为了尽可能地剪枝我额外做的工作</span></span><br><span class="line"><span class="comment">// 1. 降序排序, 到大于的时候直接 continue</span></span><br><span class="line"><span class="comment">// 2. 去重，相邻元素必须从左往右被使用</span></span><br><span class="line"><span class="comment">// 3. 索引从 start 开始</span></span><br><span class="line"><span class="keyword">int</span> targetSum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(total % k &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    used.resize(nums.size());</span><br><span class="line">    targetSum = total / k;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> canPartitionKSubsets(nums, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(curSum == targetSum) <span class="keyword">return</span> canPartitionKSubsets(nums, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 剪枝 1</span></span><br><span class="line">        <span class="keyword">if</span>(curSum + nums[i] &gt; targetSum)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 剪枝 2</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; !used[i - <span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionKSubsets(nums, k, start + <span class="number">1</span>, curSum + nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55. Jump Game</a></h5><blockquote>
<p>  给定一个非负整数数组<code>nums</code>，你最初位于数组的<strong>第一个下标</strong>。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也就是问你最多能跳多远</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == farthest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. Jump Game II</a></h5><blockquote>
<p>  给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,0,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示从索引 i 开始跳, 跳到最后需要跳的最少次数</span></span><br><span class="line"><span class="comment">// 显然 dp[n - 1] = 0, 我们要求的是 dp[0]</span></span><br><span class="line"><span class="comment">// dp[i] = 1 + min(dp[j]) j = i .. (i + nums[i])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    dp[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; n; j++)</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i + j]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">索引 2 的覆盖范围最远</th>
<th align="center">就以其最远索引作为下次起跳的位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="image-20210428181037785.png" alt="image-20210428181037785" style="zoom: 50%;" /></td>
<td align="center"><img src="image-20210428181149058.png" alt="image-20210428181149058" style="zoom:50%;" /></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心, 优先跳到下次能跳最远的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == end)</span><br><span class="line">        &#123;</span><br><span class="line">            jumps++;</span><br><span class="line">            end = farthest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. Jump Game III</a></h5><blockquote>
<p>  这里有一个非负整数数组<code>arr</code>，你最开始位于该数组的起始下标<code>start</code>处。当你位于下标<code>i</code>处时，你可以跳到<code>i + arr[i]</code>或者<code>i - arr[i]</code>。请你判断自己是否能够跳到对应元素值为<code>0</code>的任一下标处。注意，不管是什么情况下，你都无法跳到数组之外。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">All possible ways to reach at index 3 with value 0 are: </span><br><span class="line">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0</span><br><span class="line">Output: true </span><br><span class="line">Explanation: </span><br><span class="line">One possible way to reach at index 3 with value 0 is: </span><br><span class="line">index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,0,2,1,2], start &#x3D; 2</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to reach at index 1 with value 0.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= start &lt; arr.length</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(visited[pos]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[pos] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[pos] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos + arr[pos] &lt; n)</span><br><span class="line">            q.push(pos + arr[pos]);</span><br><span class="line">        <span class="keyword">if</span>(pos - arr[pos] &gt;= <span class="number">0</span>)</span><br><span class="line">            q.push(pos - arr[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> canReach(arr, start, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; <span class="number">0</span> || start &gt;= arr.size() || visited[start])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[start] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(canReach(arr, start - arr[start], visited))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(canReach(arr, start + arr[start], visited))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[start] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a><a href="https://leetcode.com/problems/jump-game-iv/" target="_blank" rel="noopener">1345. Jump Game IV</a></h5><blockquote>
<p>  给你一个整数数组<code>arr</code>，你一开始在数组的第一个元素处（下标为<code>0</code>）。每一步，你可以从下标<code>i</code>跳到下标：</p>
<ul>
<li><p><code>i + 1</code>满足：<code>i + 1 &lt; arr.length</code></p>
</li>
<li><p><code>i - 1</code>满足：<code>i - 1 &gt;= 0</code></p>
</li>
<li><p><code>j</code>满足：<code>arr[i] == arr[j]</code>且<code>i != j</code></p>
<p>请你返回到达数组最后一个元素的下标处所需的<strong>最少操作次数</strong>。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Start index is the last index. You don&#39;t need to jump.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [7,6,9,6,9,6,9,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can jump directly from index 0 to index 7 which is last index of the array.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [6,1,9]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 5:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [11,22,7,7,7,7,7,7,7,22,13]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索最短路径显然用 bfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; canJumpTo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        canJumpTo[arr[i]].push_back(i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pos == n - <span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[pos - <span class="number">1</span>])</span><br><span class="line">                q.push(pos - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pos + <span class="number">1</span> &lt; n &amp;&amp; !visited[pos + <span class="number">1</span>])</span><br><span class="line">                q.push(pos + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> jumpTo : canJumpTo[arr[pos]])</span><br><span class="line">                <span class="keyword">if</span>(!visited[jumpTo])</span><br><span class="line">                    q.push(jumpTo);</span><br><span class="line">            <span class="comment">// 同一高度的都已经放入队列等待访问了, 下次就不用再放一次了</span></span><br><span class="line">            <span class="comment">// 必须清空, 否则会 TLE</span></span><br><span class="line">            canJumpTo[arr[pos]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这题遇到一个新情况, 把 unordered_map&lt;int, vector&lt;int&gt;&gt; canJumpTo;</span></span><br><span class="line"><span class="comment">// 里的 vector&lt;int&gt; 换成 unordered_set&lt;int&gt;</span></span><br><span class="line"><span class="comment">// 把清空语句 canJumpTo[arr[pos]] = &#123;&#125;; 变成</span></span><br><span class="line"><span class="comment">// canJumpTo[arr[pos]].clear(); 会超时, 但用 swap 函数就不会</span></span><br><span class="line"><span class="comment">// unordered_set&lt;int&gt; temp; canJumpTo[arr[pos]]swap(temp);</span></span><br><span class="line"><span class="comment">// 奇了怪了!</span></span><br></pre></td></tr></table></figure>

<h5 id="403-Frog-Jump"><a href="#403-Frog-Jump" class="headerlink" title="403. Frog Jump"></a><a href="https://leetcode.com/problems/frog-jump/" target="_blank" rel="noopener">403. Frog Jump</a></h5><blockquote>
<p>  一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>  给你石子的位置列表<code>stones</code>（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>
<p>  开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格<code>1</code>跳至单元格<code>2</code>）。</p>
<p>  如果青蛙上一步跳跃了<code>k</code>个单位，那么它接下来的跳跃距离只能选择为<code>k - 1</code>、<code>k</code>或<code>k + 1</code>个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [0,1,3,5,6,8,12,17]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [0,1,2,3,4,8,9,11]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= stones.length &lt;= 2000</code></li>
<li><code>0 &lt;= stones[i] &lt;= 231 - 1</code></li>
<li><code>stones[0] == 0</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stones, <span class="keyword">int</span> pos, <span class="keyword">int</span> lastJump)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos + <span class="number">1</span> == stones.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">string</span> key = to_string(pos) + <span class="string">","</span> + to_string(lastJump);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; stones.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// k 是下一次必须跳的步数</span></span><br><span class="line">        <span class="keyword">int</span> k = stones[i] - stones[pos];</span><br><span class="line">        <span class="keyword">if</span>(k &lt; lastJump - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; lastJump + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[key] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(stones, i, k))</span><br><span class="line">            <span class="keyword">return</span> memo[key] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[key] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示是否可以用 j 步 跳到 第 i 块石头上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="comment">// k 是每次跳的步数, 每跳 1 次下次最多加 1 步</span></span><br><span class="line">            <span class="comment">// 但是升序数组的索引 j 每次至少会加 1 所以 k &lt;= j</span></span><br><span class="line">            <span class="comment">// 在第 j 块石头时，再次起跳距离最大为 j + 1</span></span><br><span class="line">            <span class="comment">// 如果和后一块石头的距离大于最大起跳距离, 就不可能跳过去</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; j + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[n - <span class="number">1</span>][k]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching</a></h5><blockquote>
<p>  给你一个字符串<code>s</code>和一个模式串<code>p</code>，请你来实现一个支持<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式匹配。</p>
<ul>
<li><p><code>&#39;.&#39;</code>匹配任意单个字符</p>
</li>
<li><p><code>&#39;*&#39;</code>匹配零个或多个前面的那一个元素</p>
<p>所谓匹配，是要涵盖整个字符串<code>s</code>的，而不是部分字符串。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;, p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 5:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;mississippi&quot;, p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 20</code></li>
<li><code>0 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> contains only lowercase English letters.</li>
<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li>
<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示 s 的前 i 个字符是否和 p 的前 j 个字符相匹配</span></span><br><span class="line"><span class="comment">// 显然我们的目标是求 dp[n][m]</span></span><br><span class="line"><span class="comment">// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时</span></span><br><span class="line"><span class="comment">// p[j - 1] 只能选择和 s[i - 1] 进行匹配</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j - 1] if s[i - 1] == p[j - 1] or p[j - 1] == '.'</span></span><br><span class="line"><span class="comment">//     dp[i][j] = false if s[i - 1] != p[j - 1] and p[j - 1] != '.'</span></span><br><span class="line"><span class="comment">// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时</span></span><br><span class="line"><span class="comment">// p[j - 2] 和 '*' 就组合在一起看</span></span><br><span class="line"><span class="comment">// 2.1 匹配 0 次</span></span><br><span class="line"><span class="comment">//     dp[i][j] = dp[i][j - 2] 不管 p[j - 2] 是否匹配 s[i - 1]</span></span><br><span class="line"><span class="comment">// 2.1 匹配多次</span></span><br><span class="line"><span class="comment">//     dp[i][j] = dp[i - 1][j] if s[i - 1] == p[j - 2] or p[j - 2] == '.'</span></span><br><span class="line"><span class="comment">// 两个空串默认可以匹配 dp[0][0] = true</span></span><br><span class="line"><span class="comment">// 但是这题要特别注意的是, 当 s 为空串时, p 为空串的情况可以是</span></span><br><span class="line"><span class="comment">// "", "c*", "c*c*", ... 它们都应该为 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 特别处理 p 为 c*c*... 的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时</span></span><br><span class="line">            <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// else</span></span><br><span class="line">                <span class="comment">//     dp[i][j] = false;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.1 匹配 0 次</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 2.1 匹配多次</span></span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. Burst Balloons"></a><a href="https://leetcode.com/problems/burst-balloons/" target="_blank" rel="noopener">312. Burst Balloons</a></h5><blockquote>
<p>  有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p>
<p>  现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。这里的<code>i - 1</code>和<code>i + 1</code>代表和i相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p>
<p>  求所能获得<strong>硬币的最大数量</strong>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,5,8]</span><br><span class="line">Output: 167</span><br><span class="line">Explanation:</span><br><span class="line">nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</span><br><span class="line">coins &#x3D;  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 &#x3D; 167</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示将第 i 个气球和第 j 个气球(左右开区间)之间的气球戳破最多得到的硬币数</span></span><br><span class="line"><span class="comment">// 显然我们是要求 dp[0][n+1]</span></span><br><span class="line"><span class="comment">// 对于第 i 个气球和第 j 个气球之间的所有气球, 我们考虑最后戳破的那一个气球 k</span></span><br><span class="line"><span class="comment">// 于是可得 dp[i][j] = dp[i][k] + dp[k][j] + nums[i - 1] * nums[k - 1] * nums[j - 1]</span></span><br><span class="line"><span class="comment">// 因为我们要求最大得到的硬币数量, 就对每一个 k 分别计算, 取最大呗</span></span><br><span class="line"><span class="comment">// 当 (i, j) 区间内没有气球时得分显然是 0, 即当 i &gt;= j 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 考虑到边界条件, 在最左最右各放两个虚拟气球</span></span><br><span class="line">    nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">    nums.insert(nums.end(), <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = max(dp[i][j],</span><br><span class="line">                               dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="887-Super-Egg-Drop"><a href="#887-Super-Egg-Drop" class="headerlink" title="887. Super Egg Drop"></a><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. Super Egg Drop</a></h5><blockquote>
<p>  给你<code>k</code>枚相同的鸡蛋，并可以使用一栋从第<code>1</code>层到第<code>n</code>层共有<code>n</code>层楼的建筑。</p>
<p>  已知存在楼层<code>f</code>，满足<code>0 &lt;= f &lt;= n</code>，任何从高于<code>f</code>的楼层落下的鸡蛋都会碎，从<code>f</code>楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>  每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层<code>x</code>扔下（满足<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。</p>
<p>  请你计算并返回要确定<code>f</code>确切的值的<strong>最坏情况下的最小尝试次数</strong>？</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 1, n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Drop the egg from floor 1. If it breaks, we know that f &#x3D; 0.</span><br><span class="line">Otherwise, drop the egg from floor 2. If it breaks, we know that f &#x3D; 1.</span><br><span class="line">If it does not break, then we know f &#x3D; 2.</span><br><span class="line">Hence, we need at minimum 2 moves to determine with certainty what the value of f is.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, n &#x3D; 6</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 14</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归 TLE!</span></span><br><span class="line"><span class="comment">// 定义 dp(k, n) 表示有 k 个鸡蛋和 n 层楼时的最坏情况下的最少尝试次数</span></span><br><span class="line"><span class="comment">// 对于从第 1 层到第 n 层中间的某一层 i, 我们扔完之后有两种情况</span></span><br><span class="line"><span class="comment">// 1. 鸡蛋没碎</span></span><br><span class="line"><span class="comment">// 这时我们要寻找的楼层 f 显然在第 i + 1 层到第 n 层之间的共 n - i 层楼</span></span><br><span class="line"><span class="comment">// 于是问题规模缩小至 dp(k, n - i)</span></span><br><span class="line"><span class="comment">// 2. 鸡蛋碎了</span></span><br><span class="line"><span class="comment">// 这时我们要寻找的楼层 f 显然在第 1 层到第 i - 1 层之间的共 i - 1 层楼</span></span><br><span class="line"><span class="comment">// 于是问题规模缩小至 dp(k - 1, i - 1)</span></span><br><span class="line"><span class="comment">// 因为我们要求最坏情况下的最少尝试次数, 什么叫最坏情况下呢？</span></span><br><span class="line"><span class="comment">// 就是说我们并不知道扔完之后鸡蛋碎不碎, 我们要考虑碎或者不碎时的最多尝试次数</span></span><br><span class="line"><span class="comment">// 什么是最少尝试次数呢？就是说我们从第 1 层, 第 2 层...第 n 层依次试一遍, 取最小值</span></span><br><span class="line"><span class="comment">// 所以 dp(k, n) = min(max(dp(k, n - i), dp(k - 1, i - 1))) for x in 1...n</span></span><br><span class="line"><span class="comment">// 当 n == 0 时, 不用扔就可以确定, dp(k, 1) = 0</span></span><br><span class="line"><span class="comment">// 当 n == 1 时, 显然至多至少都是要扔 1 次, dp(k, 1) = 1</span></span><br><span class="line"><span class="comment">// 当 k == 1 时, 显然需要从 1 到 n 一层一层尝试 dp(1, n) = n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dp(k, n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[k][n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = min(res, <span class="number">1</span> + max(dp(k, n - i, memo), dp(k - <span class="number">1</span>, i - <span class="number">1</span>, memo)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[k][n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="1601009732-AqPWoe-file_1601009732619.jpg" alt="img" style="zoom: 50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归 + 二分搜索优化 AC!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dp(k, n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 dp(k, n) 我们观察到 这是一个关于 n 的单调递增函数</span></span><br><span class="line"><span class="comment">// 也就是说在鸡蛋数固定的情况下, 楼层 n 越多, 需要的尝试次数一定不会变少</span></span><br><span class="line"><span class="comment">// 对于我们得出的这两个子问题 dp(k, n - i) 和 dp(k - 1, i - 1)</span></span><br><span class="line"><span class="comment">// 前者随着 i 的增加而减少, 后者随着 i 的增加而增加</span></span><br><span class="line"><span class="comment">// 将其想象成两条直线, 一个单调递增一个单调递减, 我们要求得一个位置 i 使得它们的最大值最小</span></span><br><span class="line"><span class="comment">// 交点处！没错在它们的交点处能满足</span></span><br><span class="line"><span class="comment">// 我们可以利用二分来查找它们的交点, 看上面的图形就明白如何应用二分了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[k][n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> notBroken = dp(k, n - mi, memo);</span><br><span class="line">        <span class="keyword">int</span> broken = dp(k - <span class="number">1</span>, mi - <span class="number">1</span>, memo);</span><br><span class="line">        <span class="keyword">if</span>(notBroken &gt;= broken) &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">            res = min(res, notBroken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">            res = min(res, broken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[k][n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a></h5><blockquote>
<p>  你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果<strong>两间相邻的房屋</strong>在同一晚上被小偷闯入，系统会自动报警。</p>
<p>  给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示从第 i 间 (i 从 0 算起) 房屋开始打劫最多能抢到的钱</span></span><br><span class="line"><span class="comment">// 对于第 i 间房屋我们有 2 个选择</span></span><br><span class="line"><span class="comment">// 1. 不抢</span></span><br><span class="line"><span class="comment">// dp[i] = dp[i + 1]</span></span><br><span class="line"><span class="comment">// 2. 抢</span></span><br><span class="line"><span class="comment">// dp[i] = nums[i] + dp[i + 2]</span></span><br><span class="line"><span class="comment">// 要求最多能抢多少钱, 两种选择取大值</span></span><br><span class="line"><span class="comment">// 即 dp[i] = max(dp[i + 1], nums[i] + dp[i + 2])</span></span><br><span class="line"><span class="comment">// 我们要求的目标是 dp[0]</span></span><br><span class="line"><span class="comment">// 当 i == n 时, 没房子抢了, dp[n] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前状态只依赖前两个状态, 可进行空间优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">0</span>, dp_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp_0 = max(dp_1, nums[i] + dp_2);</span><br><span class="line">        dp_2 = dp_1;</span><br><span class="line">        dp_1 = dp_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二: 重新定义 dp 数组</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示不抢第 i 间房屋时, 经过了前 i 间所获得的金钱</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示抢第 i 间房屋, 经过了前 i 间所获得的金钱</span></span><br><span class="line"><span class="comment">// 那么 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])</span></span><br><span class="line"><span class="comment">// dp[i][1] = dp[i - 1][0] + nums[i - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 此家不抢, 上家可抢可不抢, 看哪个收益大</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 此家抢, 上家不能抢</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. House Robber II</a></h5><blockquote>
<p>  你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>  给定一个代表每个房屋存放金额的非负整数数组，计算你在<strong>不触动警报装置的情况</strong>下，今晚能够偷窃到的最高金额。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在题 I 的基础上, 只需考虑三种情况</span></span><br><span class="line"><span class="comment">// 1. 第 0 间和第 n - 1 间都不抢</span></span><br><span class="line"><span class="comment">// 2. 第 0 间抢那么第 n - 1 间就不能抢</span></span><br><span class="line"><span class="comment">// 3. 第 n - 1 间抢那么第 0 间就不能抢</span></span><br><span class="line"><span class="comment">// 比较这三种情况, 取大值即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(&#123;rob(nums, <span class="number">1</span>, n - <span class="number">2</span>), rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">0</span>, dp_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">        dp_0 = max(dp_1, nums[i] + dp_2);</span><br><span class="line">        dp_2 = dp_1;</span><br><span class="line">        dp_1 = dp_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. House Robber III</a></h5><blockquote>
<p>  在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>  计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>  <strong>Example 1:</strong></p>
  <img src="rob1-tree.jpg" alt="img" style="zoom: 67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,2,3,null,3,null,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Maximum amount of money the thief can rob &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <img src="rob2-tree.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,4,5,1,3,null,1]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Maximum amount of money the thief can rob &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 I 题方法 2 的思路下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;不抢 root 最多得到的钱, 抢 root 最多得到的钱&gt;</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [](<span class="keyword">auto</span>&amp;&amp; dfs, TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [l_norob, l_rob] = dfs(dfs, root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [r_norob, r_rob] = dfs(dfs, root-&gt;right);</span><br><span class="line">        <span class="comment">// 不抢, 左右两家家可抢可不抢, 看哪个收益大</span></span><br><span class="line">        <span class="keyword">auto</span> norob = max(l_norob, l_rob) + max(r_norob, r_rob);</span><br><span class="line">        <span class="comment">// 抢, 左右两家不能抢</span></span><br><span class="line">        <span class="keyword">auto</span> rob = l_norob + root-&gt;val + r_norob;</span><br><span class="line">        <span class="keyword">return</span> make_pair(norob, rob);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> [norob, rob] = dfs(dfs, root);</span><br><span class="line">    <span class="keyword">return</span> max(norob, rob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a><a href="https://leetcode.com/problems/delete-and-earn/" target="_blank" rel="noopener">740. Delete and Earn</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，你可以对它进行一些操作。</p>
<p>  每次操作中，选择任意一个<code>nums[i]</code>，删除它并获得<code>nums[i]</code>的点数。之后，你必须删除每个等于<code>nums[i] - 1</code>或<code>nums[i] + 1</code>的元素。</p>
<p>  开始你拥有<code>0</code>个点数。返回你能通过这些操作获得的<strong>最大点数</strong>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted.</span><br><span class="line">Then, delete 2 to earn 2 points.</span><br><span class="line">6 total points are earned.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,3,3,3,4]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Delete 3 to earn 3 points, deleting both 2&#39;s and the 4.</span><br><span class="line">Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span><br><span class="line">9 total points are earned.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在选择了元素 x 后, x, x - 1, x + 1 都会被删除</span></span><br><span class="line"><span class="comment">// 并且我们可以一下选择剩余的所有 x 以尽可能多的获得点数</span></span><br><span class="line"><span class="comment">// 如果我们定义 dp[i] 表示元素 i 开始选择可以获得的点数</span></span><br><span class="line"><span class="comment">// 选择元素 i 获得的点数等于 i * (i 出现的次数)</span></span><br><span class="line"><span class="comment">// 那么这题就和上面的打家劫舍题 I 相同了</span></span><br><span class="line"><span class="comment">// 也即是说抢劫了第 i 间房屋, i - 1 和 i + 1 都不能抢了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(maxVal + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        counts[num]++;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(maxVal + <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxVal; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        dp[i] = max(dp[i + <span class="number">1</span>], i * counts[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理一下, 可以直接调用打家劫舍的 rob 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// sum[x] 等于所有 x 之和</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(maxVal + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        sum[num] += num;</span><br><span class="line">    <span class="keyword">return</span> rob(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        dp[i] = max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. Maximum Subarray</a></h5><blockquote>
<p>  给定一个整数数组<code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力 超时</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n2) 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            res = max(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和</span></span><br><span class="line"><span class="comment">// 时间复杂度和空间复杂度均为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 dp[i] 只与上一个状态 dp[i - 1] 和 nums[i] 有关</span></span><br><span class="line"><span class="comment">// 通过一个变量记录上一个状态值将空间复杂度压缩到 O(1)</span></span><br><span class="line"><span class="comment">// 并且同时使用一个变量更新状态中的最大值</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n) 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> preState = <span class="number">0</span>, curState = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        curState = nums[i];</span><br><span class="line">        <span class="keyword">if</span>(preState &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curState += preState;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, curState);</span><br><span class="line">        preState = curState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法 (还没搞懂)</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(nlogn) 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binary_search(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = binary_search(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> rightMax = binary_search(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> midMax = nums[mid], t = midMax;</span><br><span class="line">    <span class="comment">// 开始计算左边的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">        t += nums[i];</span><br><span class="line">        midMax = max(midMax, t);</span><br><span class="line">    &#125;</span><br><span class="line">    t = midMax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        t += nums[i];</span><br><span class="line">        midMax = max(midMax, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(midMax, max(leftMax, rightMax));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<ul>
<li>参考链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/dong-tai-gui-hua-li-jie-wu-hou-xiao-xing-by-liweiw/" target="_blank" rel="noopener">动态规划（理解无后效性） - 乘积最大子数组</a></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果还是定义 dp[i] 表示以 nums[i] 结尾的连续子数组的最大乘积</span></span><br><span class="line"><span class="comment">// 继续以 53 题的思路解决这道题是错误的做法</span></span><br><span class="line"><span class="comment">// 因为数组中负数的出现会使得正的最大值乘以负数而可能变成最小值</span></span><br><span class="line"><span class="comment">// 而负的最小值乘以一个负数而可能会变成最大值</span></span><br><span class="line"><span class="comment">// 也就是说乘积的最大值和最小值会由于当前的数的正负而发生转化</span></span><br><span class="line"><span class="comment">// 所以这题要根据 nums[i] 的正负来分别考虑以 nums[i] 结尾的子数组的最大值和最小值两种情况</span></span><br><span class="line"><span class="comment">// 定义 dp[0][i] 和 dp[1][i] 分别表示以 nums[i] 结尾的子数组的乘积的最小值和最大值</span></span><br><span class="line"><span class="comment">// 当 nums[i] &gt; 0 时</span></span><br><span class="line"><span class="comment">// dp[0][i] = min(nums[i] * dp[0][i - 1], nums[i])</span></span><br><span class="line"><span class="comment">// dp[1][i] = max(nums[i] * dp[1][i - 1], numa[i])</span></span><br><span class="line"><span class="comment">// 当 nums[i] &lt; 0 时</span></span><br><span class="line"><span class="comment">// dp[0][i] = min(nums[i] * dp[1][i - 1], nums[i])</span></span><br><span class="line"><span class="comment">// dp[1][i] = max(nums[i] * dp[0][i - 1], numa[i])</span></span><br><span class="line"><span class="comment">// 这题也可以问你连续子数组的最小乘积是多少</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>] * nums[i], nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] * nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>] * nums[i], nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] * nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, dp[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前状态只依赖前一个状态, 故可以使用滚动变量进行空间优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp_0_0 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dp_1_0 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp_1_0;</span><br><span class="line">    <span class="comment">// 滚动变量</span></span><br><span class="line">    <span class="keyword">int</span> dp_0_1, dp_1_1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp_0_1 = min(nums[i] * dp_0_0, nums[i]);</span><br><span class="line">            dp_1_1 = max(nums[i] * dp_1_0, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp_0_1 = min(nums[i] * dp_1_0, nums[i]);</span><br><span class="line">            dp_1_1 = max(nums[i] * dp_0_0, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp_0_0 = dp_0_1;</span><br><span class="line">        dp_1_0 = dp_1_1;</span><br><span class="line">        res = max(res, dp_1_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">1262. Greatest Sum Divisible by Three</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，请你找出并返回能被<code>3</code>整除的<strong>元素最大和</strong>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,6,5,1,8]</span><br><span class="line">Output: 18</span><br><span class="line">Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Since 4 is not divisible by 3, do not pick any number.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,4]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 4 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示对于前 i 个数, 选取的数字和对 3 取余为 j 的最大和 (j == 0, 1, 2)</span></span><br><span class="line"><span class="comment">// 我们的目标是要求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 那么如果进行状态转移呢？</span></span><br><span class="line"><span class="comment">// 需要看第 i 个数 nums[i - 1] 对 3 取余的情况</span></span><br><span class="line"><span class="comment">// 1. 余数为 0</span></span><br><span class="line">    <span class="comment">// 加到哪一个最大和身上对 3 取余的结果不变</span></span><br><span class="line">    <span class="comment">// dp[i][0] = max(dp[i - 1][0], dp[i - 1][0] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][1] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// dp[i][2] = max(dp[i - 1][2], dp[i - 1][2] + nums[i - 1])</span></span><br><span class="line"><span class="comment">// 2. 余数为 1</span></span><br><span class="line">    <span class="comment">// 加到原来余 2 的最大和身上, 余数变成 0</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 0 的最大和身上, 余数变成 1</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 1 的最大和身上, 余数变成 2</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + nums[i - 1])</span></span><br><span class="line"><span class="comment">// 3. 余数为 2</span></span><br><span class="line">    <span class="comment">// 加到原来余 1 的最大和身上, 余数变成 0</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 2 的最大和身上, 余数变成 1</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][1] = max(dp[i - 1][1], dp[i - 1][2] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 0 的最大和身上, 余数变成 2</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][2] = max(dp[i - 1][2], dp[i - 1][0] + nums[i - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k 为任意数的一般情况</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k))</span></span>;</span><br><span class="line">    <span class="comment">// 这个初始化有点不太好想到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = nums[i - <span class="number">1</span>] % k;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(k - mod + j) % k] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在理解了上一种解法的基础上, 下面这种思路更好</span></span><br><span class="line"><span class="comment">// dp[i] 表示选择的数字累加和模 3 == i 的数字和</span></span><br><span class="line"><span class="comment">// 对于 nums[i], 如果 nums[i] % 3 == 1, 那么将其加到之前模 3 == 2 的最大和上面</span></span><br><span class="line"><span class="comment">// 就变成了模 3 == 0 了, 所以 dp[0] = max(dp[0], dp[2] + nums[i])</span></span><br><span class="line"><span class="comment">// 依次类推, 对于每一个 nums[i] 都要更新 dp 数组的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k 为任意数的一般情况</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 备份上一个状态</span></span><br><span class="line">        <span class="comment">// 因为要用上一个状态的值来更新当前状态</span></span><br><span class="line">        <span class="keyword">auto</span> temp = dp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> maxSum : temp) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = (maxSum + num) % k;</span><br><span class="line">            dp[mod] = max(dp[mod], maxSum + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a><a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. Predict the Winner</a></h5><blockquote>
<p>  给定一个表示分数的非负整数数组。 玩家<code>A</code>从数组任意一端拿取一个分数，随后玩家<code>B</code>继续从剩余数组任意一端拿取分数，然后玩家<code>A</code>拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>  给定一个表示分数的数组，预测作为先手的玩家<code>A</code>是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<ul>
<li>如果最终两个玩家的分数相等，那么玩家<code>A</code>仍为赢家。</li>
</ul>
<p>  <strong>示例：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j][0] 表示先手在面对 nums[i..j] 的石头堆时能拿到的最大分数</span></span><br><span class="line"><span class="comment">// dp[i][j][1] 表示后手在面对 nums[i..j] 的石头堆时能拿到的最大分数</span></span><br><span class="line"><span class="comment">// 1. 对于石头堆 nums[i..j]</span></span><br><span class="line"><span class="comment">//    先手需要判断拿左边堆分数高还是拿右边堆分数高</span></span><br><span class="line"><span class="comment">//    如果先手拿了左边堆, 先手面对 nums[i+1..j] 时就变成了后手</span></span><br><span class="line"><span class="comment">//    此时的得分是 dp[i + 1][j][1] + nums[i]</span></span><br><span class="line"><span class="comment">//    如果先手拿了右边堆, 先手面对 nums[i..j-1] 时就变成了后手</span></span><br><span class="line"><span class="comment">//    此时的得分是 dp[i][j - 1][1] + nums[j]</span></span><br><span class="line"><span class="comment">//    肯定取较高的情况</span></span><br><span class="line"><span class="comment">//    dp[i][j][0] = max(dp[i + 1][j][1] + nums[i], dp[i][j - 1][1] + nums[j])</span></span><br><span class="line"><span class="comment">// 2. 先手的选择对后手会产生影响, 如果先手选择了左边堆</span></span><br><span class="line"><span class="comment">//    后手在面对 nums[i+1..j] 时就变成了先手</span></span><br><span class="line"><span class="comment">//    dp[i][j][1] = dp[i + 1][j][0]</span></span><br><span class="line"><span class="comment">//    如果先手选择了右边堆</span></span><br><span class="line"><span class="comment">//    后手在面对 nums[i..j-1] 时就变成了先手</span></span><br><span class="line"><span class="comment">//    dp[i][j][1] = dp[i][j - 1][0]</span></span><br><span class="line"><span class="comment">// 当 i &gt; j 时, 没有石头堆了 dp[i][j][0,1] = 0</span></span><br><span class="line"><span class="comment">// 当 i == j 时, dp[i][j][0] = nums[i], dp[i][j][1] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i][<span class="number">0</span>] = nums[i];</span><br><span class="line">        dp[i][i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 比较拿左边堆之后和拿右边堆之后的分数</span></span><br><span class="line">            <span class="keyword">int</span> left = dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + nums[i];</span><br><span class="line">            <span class="keyword">int</span> right = dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + nums[j];</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = left;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = dp[i + <span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = right;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不可以写成这样, 不能仅仅比较当前左右两堆石头的大小</span></span><br><span class="line">            <span class="comment">// 比如 [1, 5, 233, 7] 的情况</span></span><br><span class="line">            <span class="comment">// if(nums[i] &gt; nums[j])</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     dp[i][j][0] = dp[i + 1][j][1] + nums[i];</span></span><br><span class="line">            <span class="comment">//     dp[i][j][1] = dp[i + 1][j][0];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     dp[i][j][0] = dp[i][j - 1][1] + nums[j];</span></span><br><span class="line">            <span class="comment">//     dp[i][j][1] = dp[i][j - 1][0];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">0</span>] &gt;= dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划的另一种思路</span></span><br><span class="line"><span class="comment">// 甲乙比赛, 甲先手面对区间 [i...j] 时, dp[i][j] 表示甲对乙的净胜分</span></span><br><span class="line"><span class="comment">// 最终求的就是, 甲先手面对区间 [0...n-1] 时, 甲对乙的净胜分 dp[0][n-1] 是否 &gt;= 0</span></span><br><span class="line"><span class="comment">// 甲先手面对区间[i...j]时</span></span><br><span class="line"><span class="comment">// 1. 如果甲拿 nums[i], 那么变成乙先手面对区间 [i+1...j], 这段区间内乙对甲的净胜分为 dp[i+1][j]</span></span><br><span class="line"><span class="comment">// 那么甲对乙的净胜分就应该是 nums[i] - dp[i+1][j]</span></span><br><span class="line"><span class="comment">// 如果甲拿 nums[j], 同理可得甲对乙的净胜分为是 nums[j] - dp[i][j-1]</span></span><br><span class="line"><span class="comment">// 以上两种情况二者取大即可</span></span><br><span class="line"><span class="comment">// 状态转移方程 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="comment">// 当 i == j 时先手对后手的净胜分就是 nums[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            dp[i][j] = max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="486_fig1.png" alt="fig1" style="zoom: 50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> totalScores(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回拿走 [i, j] 的石头堆后的的得分</span></span><br><span class="line"><span class="comment">// flag = 1 表示当前是先手, flag = -1 表示当前是后手</span></span><br><span class="line"><span class="comment">// flag 可用于控制先手的得分均为正值, 后手的得分均为负值</span></span><br><span class="line"><span class="comment">// 交替选择的过程中将他们的分数加起来</span></span><br><span class="line"><span class="comment">// 显然, 最后总得分为正时先后获胜, 为负时后手获胜</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalScores</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> key = to_string(i) + <span class="string">","</span> + to_string(j) + <span class="string">","</span> + to_string(flag);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> selectLeft = flag * nums[i] + totalScores(nums, i + <span class="number">1</span>, j, -flag);</span><br><span class="line">    <span class="keyword">int</span> selectRight = flag * nums[j] + totalScores(nums, i, j - <span class="number">1</span>, -flag);</span><br><span class="line">    <span class="comment">// 无论当前是先后还是后手, 其选择左或右后, 目前得分的总和可能为正也可能为负</span></span><br><span class="line">    <span class="comment">// 所以需要去掉正负号后再选出较大的值, 方法就是 得分*flag 就可以</span></span><br><span class="line">    <span class="comment">// 也就是说先手会尽量的把数变正变大</span></span><br><span class="line">    <span class="comment">// 后手会尽量把数变负变小</span></span><br><span class="line">    <span class="keyword">return</span> memo[key] = flag * max(flag * selectLeft, flag * selectRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="664-Strange-Printer"><a href="#664-Strange-Printer" class="headerlink" title="664. Strange Printer"></a><a href="https://leetcode.com/problems/strange-printer/" target="_blank" rel="noopener">664. Strange Printer</a></h5><blockquote>
<p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 同一个字符 组成的序列。</li>
<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串<code>s</code>，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: s &#x3D; &quot;aaabbb&quot;</span><br><span class="line">&gt;Output: 2</span><br><span class="line">&gt;Explanation: Print &quot;aaa&quot; first and then print &quot;bbb&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: s &#x3D; &quot;aba&quot;</span><br><span class="line">&gt;Output: 2</span><br><span class="line">&gt;Explanation: Print &quot;aaa&quot; first and then print &quot;b&quot; from the second place of the string, which will cover the existing character &#39;a&#39;.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j] 表示打印出字符串区间 s[i..j] 中的字符所需要的最少次数</span></span><br><span class="line"><span class="comment">// 对于 s[i] == s[j]</span></span><br><span class="line"><span class="comment">// 我们在第一次打印出 s[i] 的同时可以顺便打印出 s[j]</span></span><br><span class="line"><span class="comment">// 因此只需要关注如何更快的打印出 s[i..j-1] 中的字符即可</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - 1]</span></span><br><span class="line"><span class="comment">// 对于 s[i] != s[j]</span></span><br><span class="line"><span class="comment">// 我们要分别完成以 s[i] 开头的左半部分字符和以 s[j] 结尾的右半部分字符的打印</span></span><br><span class="line"><span class="comment">// 具体的需要在 i 到 j 之间找一个分界点 k</span></span><br><span class="line"><span class="comment">// 找到最小的 dp[i][k] + dp[k + 1][j]</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i][k] + dp[k + 1][j]) for k in [i, j)</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[0][n - 1]</span></span><br><span class="line"><span class="comment">// 当 i == j 时 dp[i][j] = 1 只需要一次打印即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可能想到的优化点</span></span><br><span class="line">    <span class="comment">// 注意到本题中连续的相同字符等价于单个字符</span></span><br><span class="line">    <span class="comment">// 所以可以先进行一个相邻元素去重处理</span></span><br><span class="line">    <span class="comment">// auto last = unique(s.begin(), s.end());</span></span><br><span class="line">    <span class="comment">// s.resize(distance(s.begin(), last));</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 dp[i][j] 依赖于 dp[i + k][j]</span></span><br><span class="line">    <span class="comment">// 所以画出二维矩阵图之后知道我们要对 i 从下往上, j 从左往右遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="546-Remove-Boxes"><a href="#546-Remove-Boxes" class="headerlink" title="546. Remove Boxes"></a><a href="https://leetcode.com/problems/remove-boxes/" target="_blank" rel="noopener">546. Remove Boxes</a></h5><blockquote>
<p>  给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。</p>
<p>  你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续<code>k</code>个盒子（<code>k &gt;= 1</code>），这样一轮之后你将得到<code>k * k</code>个积分。</p>
<p>  当你将所有盒子都去掉之后，求你能获得的<strong>最大积分和</strong>。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: boxes &#x3D; [1,3,2,2,2,3,4,3,1]</span><br><span class="line">Output: 23</span><br><span class="line">Explanation:</span><br><span class="line">[1, 3, 2, 2, 2, 3, 4, 3, 1]</span><br><span class="line">----&gt; [1, 3, 3, 4, 3, 1] (3*3&#x3D;9 points)</span><br><span class="line">----&gt; [1, 3, 3, 3, 1] (1*1&#x3D;1 points)</span><br><span class="line">----&gt; [1, 1] (3*3&#x3D;9 points)</span><br><span class="line">----&gt; [] (2*2&#x3D;4 points)</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太特么难了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; boxes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a><a href="https://leetcode.com/problems/counting-bits/?um_chnnl=huawei?um_from_appkey=5fcda41c42348b56d6f8e8d5" target="_blank" rel="noopener">338. Counting Bits</a></h5><blockquote>
<p>  给定一个非负整数<code>num</code>。对于<code>0 ≤ i ≤ num</code>范围中的每个数字<code>i</code>，计算其二进制数中的<code>1</code>的数目并将它们作为数组返回。</p>
<p>  <strong>进阶</strong>：给出时间复杂度为<code>O(n*sizeof(integer))</code>的解答非常容易。但你可以在线性时间<code>O(n)</code>内用一趟扫描做到吗？</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: [0, 1, 1, 2, 1, 2]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = countOnes(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的值时通过最高位的 1 转移到之前的状态</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的值时通过最低位的 1 转移到之前的状态</span></span><br><span class="line"><span class="comment">// 实际上就是通过把值变小, 使当前值中的 1 的个数和更小的值中 1 的个数具有数量关系</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 方式一: 右移一位, 最右边的位可能为 0 或 1</span></span><br><span class="line">        bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 方式二: 去掉最低位 1</span></span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible"><a href="#1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible" class="headerlink" title="1866. Number of Ways to Rearrange Sticks With K Sticks Visible"></a><a href="https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/?um_chnnl=huawei?um_from_appkey=5fcda41c42348b56d6f8e8d5" target="_blank" rel="noopener">1866. Number of Ways to Rearrange Sticks With K Sticks Visible</a></h5><blockquote>
<p>  有<code>n</code>根长度互不相同的木棍，长度为从<code>1</code>到<code>n</code>的整数。请你将这些木棍排成一排，并满足从左侧可以看到恰好<code>k</code>根木棍。</p>
<p>  从左侧可以看到木棍的前提是这个木棍的左侧不存在比它更长的木棍。例如，如果木棍排列为<code>[1,3,2,5,4]</code>，那么从左侧可以看到的就是长度分别为<code>1、3 、5</code>的木棍。</p>
<p>  给你<code>n</code>和<code>k</code>，返回符合题目要求的排列数目 。由于答案可能很大，请返回对<code>10^9 + 7</code>取余的结果。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.</span><br><span class="line">The visible sticks are underlined.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5, k &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.</span><br><span class="line">The visible sticks are underlined.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 20, k &#x3D; 11</span><br><span class="line">Output: 647427950</span><br><span class="line">Explanation: There are 647427950 (mod 10^9 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j] 表示对于高度为 [1..i] 的所有柱子进行排列, 从左侧能看到 j 根的排列数</span></span><br><span class="line"><span class="comment">// 我们考虑最后一根柱子能不能被看见</span></span><br><span class="line"><span class="comment">// 1. 如果最后一根柱子能被看见, 那么它的高度一定为 i</span></span><br><span class="line"><span class="comment">// 这样对于左侧 [1..i-1] 高度的柱子看到 j-1 根柱子的排列数就是之前的状态</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][ j - 1]</span></span><br><span class="line"><span class="comment">// 2. 如果最后一根柱子不能被看见, 那么它的高度可以为 [1..i-1] 中的任意一个</span></span><br><span class="line"><span class="comment">// 由于一根木棍能否被看到只与它和它左侧木棍的「相对高度关系」有关，而与「绝对高度关系」无关</span></span><br><span class="line"><span class="comment">// 因此, 此时最后一根柱子的高度有 [1..i-1] 中 i-1 种选择</span></span><br><span class="line"><span class="comment">// 固定每种选择后, 对于左侧的柱子看到 j 根柱子的排列数就是之前状态</span></span><br><span class="line"><span class="comment">// dp[i][j] = (i - 1) * dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 综合两种情况 dp[i][j] = dp[i - 1][ j - 1] + (i - 1) * dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][k]</span></span><br><span class="line"><span class="comment">// 当 i == 0 &amp;&amp; j == 0 时 dp[0][0] = 1, 其它情况都初始化为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rearrangeSticks</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(k + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (i - <span class="number">1</span>) * dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a><a href="https://leetcode.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. Split Array Largest Sum</a></h5><blockquote>
<p>  给定一个非负整数数组<code>nums</code>和一个整数<code>m</code>，你需要将这个数组分成<code>m</code>个非空的连续子数组。设计一个算法使得这<code>m</code>个子数组各自和的最大值最小。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,2,5,10,8], m &#x3D; 2</span><br><span class="line">Output: 18</span><br><span class="line">Explanation:</span><br><span class="line">There are four ways to split nums into two subarrays.</span><br><span class="line">The best way is to split it into [7,2,5] and [10,8],</span><br><span class="line">where the largest sum among the two subarrays is only 18.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j] 表示将前 i 个数划分成 j 个连续的子数组, 各自和的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="comment">// 枚举将前 k 个数划分为 j - 1 个子数组</span></span><br><span class="line">            <span class="comment">// 因为子数组非空, 所以 k in [j - 1, i - 1]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], max(dp[k][j - <span class="number">1</span>], prefix[i] - prefix[k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分 + 贪心 check</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> maxVal) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + num &lt;= maxVal) &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        hi += num;</span><br><span class="line">        <span class="keyword">if</span>(lo &lt; num) &#123;</span><br><span class="line">            lo = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mi)) &#123;</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II</a></h5><blockquote>
<p>  有一堆石头，用整数数组<code>stones</code>表示。其中<code>stones[i]</code>表示第<code>i</code>块石头的重量。</p>
<p>  每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为<code>x</code>和<code>y</code>，且<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li><p>如果<code>x == y</code>，那么两块石头都会被完全粉碎；</p>
</li>
<li><p>如果<code>x != y</code>，那么重量为<code>x</code>的石头将会完全粉碎，而重量为<code>y</code>的石头新重量为<code>y - x</code>。</p>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回<code>0</code>。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,</span><br><span class="line">we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,</span><br><span class="line">we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,</span><br><span class="line">we can combine 1 and 1 to get 0, so the array converts to [1], then that&#39;s the optimal value.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [31,26,33,21,40]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一回合的操作相当于在较大的数前面放置一个 '+' 号, 在较小的数前面放置一个 '-' 号</span></span><br><span class="line"><span class="comment">// 经过若干回合之后, 所有的数前面都被放置了相应的正负号</span></span><br><span class="line"><span class="comment">// 最后形成的表达式求值就是最终剩下的石头的重量</span></span><br><span class="line"><span class="comment">// 我们假设前面被放正号的数之和是 sumP, 前面放负号的数之和为 sumN</span></span><br><span class="line"><span class="comment">// 所有石头总和为 sum, 最后剩下的石头重量为 w</span></span><br><span class="line"><span class="comment">// 则 w = sumP - sumN = sum - sumN - sumN = sum - 2*sumN</span></span><br><span class="line"><span class="comment">// 为了保证 w 最小, 那么我们就是要保证 sum - 2*sumN 为非负值的情况下</span></span><br><span class="line"><span class="comment">// 也就是在 sumN &lt;= sum/2 时, 找到尽可能大的 sumN</span></span><br><span class="line"><span class="comment">// 此时问题就转换为了一个 01 背包问题</span></span><br><span class="line"><span class="comment">// 有一个容量为 sum/2 的背包和一堆重量已知的石头</span></span><br><span class="line"><span class="comment">// 问我们如何装能够装的石头总重量最大</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示对于前 i 堆石头, 背包容量为 j 时能装的最大重量</span></span><br><span class="line"><span class="comment">// 对于第 i 块石头有两个选择</span></span><br><span class="line"><span class="comment">// 1. 不装 dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 装 dp[i][j] = dp[i - 1][j - stones[i - 1]] + stones[i - 1]</span></span><br><span class="line"><span class="comment">// 我们要求最大可能的重量, 所以两者取最大值即可</span></span><br><span class="line"><span class="comment">// 对于初始条件, 当 i == 0 时, 即没有石头可装, dp[i][j] = 0</span></span><br><span class="line"><span class="comment">// 当 j == 0, 即背包容量为 0, dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(stones.begin(), stones.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(sum/<span class="number">2</span> + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= stones[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j] , dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span>*dp[n][sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 i 的当前状态只与前一个状态有关, 使用滚动数组优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(stones.begin(), stones.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sum/<span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum/<span class="number">2</span>; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j] , dp[j - stones[i]] + stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span>*dp[sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="879-盈利计划"><a href="#879-盈利计划" class="headerlink" title="879. 盈利计划"></a><a href="https://leetcode-cn.com/problems/profitable-schemes/" target="_blank" rel="noopener">879. 盈利计划</a></h5><blockquote>
<p>  集团里有<code>n</code>名员工，他们可以完成各种各样的工作创造利润。第<code>i</code>种工作会产生<code>profit[i]</code>的利润，它要求<code>group[i]</code>名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>  工作的任何至少产生<code>minProfit</code>利润的子集称为<strong>盈利计划</strong>。并且工作的成员总数最多为<code>n</code>。</p>
<p>  有多少种计划可以选择？因为答案可能很大，所以返回结果模<code>10^9 + 7</code>的值。</p>
<p>  <strong>示例 1</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, minProfit &#x3D; 3, group &#x3D; [2,2], profit &#x3D; [2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。</span><br><span class="line">总的来说，有两种计划。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 2</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10, minProfit &#x3D; 5, group &#x3D; [2,3,5], profit &#x3D; [6,7,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。</span><br><span class="line">有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</span><br></pre></td></tr></table></figure>


<p>  提示：</p>
<ul>
<li>1 &lt;= n &lt;= 100，0 &lt;= <code>minProfit</code> &lt;= 100，1 &lt;= <code>group.length</code> &lt;= 100</li>
<li>1 &lt;= group[i] &lt;= 100，<code>profit.length</code> == <code>group.length</code>，0 &lt;= profit[i] &lt;= 100</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态有工作, 员工数以及当前利润</span></span><br><span class="line"><span class="comment">// 我们定义 dp[i][j][k] 表示对于前 i 种工作, 参与的员工数为 j 时, 在利润 [至少] 为 k 的情况下的计划数</span></span><br><span class="line"><span class="comment">// 对于第 i 种工作我们有选择和不选两种选择</span></span><br><span class="line"><span class="comment">// 1. 不选 显然有</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j][k]</span></span><br><span class="line"><span class="comment">// 2. 选</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j - group[i - 1]][k - profit[i - 1]]</span></span><br><span class="line"><span class="comment">// 注意到对于状态 k 我们定义的是至少获得的利润</span></span><br><span class="line"><span class="comment">// 因此, 当 k - profit[i - 1] 为负时, 我们都取 0</span></span><br><span class="line"><span class="comment">// 也就是说所有大于 k 的利润都归为等于 k, 这就是至少的定义嘛</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, 无论你用了多少个员工, 至少获得的利润 k 显然都为 0, 这属于 1 种计划</span></span><br><span class="line"><span class="comment">// dp[0][j][0] = 1 for j in [1..n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> minProfit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = group.size();</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(minProfit + <span class="number">1</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= minProfit; k++) &#123;</span><br><span class="line">                dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= group[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j][k] += dp[i - <span class="number">1</span>][j - group[i - <span class="number">1</span>]][max(<span class="number">0</span>, k - profit[i - <span class="number">1</span>])];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j][k] = dp[i][j][k] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n][minProfit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组优化空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> minProfit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = group.size();</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(minProfit + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= group[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= minProfit; k++) &#123;</span><br><span class="line">                dp[j][k] += dp[j - group[i - <span class="number">1</span>]][max(<span class="number">0</span>, k - profit[i - <span class="number">1</span>])];</span><br><span class="line">                dp[j][k] = dp[j][k] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][minProfit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法"></a><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. 掷骰子的N种方法</a></h5><blockquote>
<p>  这里有<code>d</code>个一样的骰子，每个骰子上都有<code>f</code>个面，分别标号为<code>1, 2, ..., f</code>。</p>
<p>  我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p>
<p>  如果需要掷出的总点数为<code>target</code>，请你计算出有多少种不同的组合情况（所有的组合情况总共有<code>f^d</code>种），模<code>1e9+7</code>后返回。</p>
<p>  <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= d, f &lt;= 30</code></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01 背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(d + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                    dp[i][j] = dp[i][j] % <span class="keyword">int</span>(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组优化空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 这个不太容易想到</span></span><br><span class="line">            <span class="comment">// 它表示降维前, dp[1..d][0] = 0 的情况</span></span><br><span class="line">            <span class="comment">// 即, 使用了多于一个骰子的话, 和为 0 的情况不可能出现</span></span><br><span class="line">            <span class="comment">// 因此, 每次迭代时要将这种情况的组合数设为 0</span></span><br><span class="line">            dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] += dp[j - k];</span><br><span class="line">                dp[j] = dp[j] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="801-使序列递增的最小交换次数"><a href="#801-使序列递增的最小交换次数" class="headerlink" title="801. 使序列递增的最小交换次数"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">801. 使序列递增的最小交换次数</a></h5><blockquote>
<p>  我们有两个长度相等且不为空的整型数组<code>A</code>和<code>B</code>。我们可以交换<code>A[i]</code>和<code>B[i]</code>的元素。注意这两个元素在各自的序列中应该处于相同的位置。在交换过一些元素之后，数组<code>A</code>和<code>B</code>都应该是严格递增的。</p>
<p>  给定数组<code>A</code>和<code>B</code>，请返回使得两个数组均保持严格递增状态的最小交换次数。<strong>假设给定的输入总是有效的</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于第 i 个元素, 有交换和不交换两种选择</span></span><br><span class="line"><span class="comment">// 定义 dp[i][0] 表示第 i 个元素交换时, 将前 i 个元素交换操作之后严格递增的最小操作次数</span></span><br><span class="line"><span class="comment">// 定义 dp[i][1] 表示第 i 个元素不交换时, 将前 i 个元素交换操作之后严格递增的最小操作次数</span></span><br><span class="line"><span class="comment">// 那么在考虑第 i 个元素时, 需要连同第 i - 1 个元素一起考虑</span></span><br><span class="line"><span class="comment">// 也就是 A[i - 1], A[i], B[i - 1] 和 B[i] 这四个元素</span></span><br><span class="line"><span class="comment">// 1. A[i - 1] &lt; A[i] &amp;&amp; B[i - 1] &lt; B[i]</span></span><br><span class="line"><span class="comment">// 此时若 A[i - 1] &lt; B[i] &amp;&amp; B[i - 1] &lt; A[i]</span></span><br><span class="line"><span class="comment">// 前一个元素可以交换也可以不交换</span></span><br><span class="line"><span class="comment">// 1.1 当前元素不交换 dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])</span></span><br><span class="line"><span class="comment">// 1.2 当前元素交换 dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + 1</span></span><br><span class="line"><span class="comment">// 此时若 A[i - 1] &gt;= B[i] || B[i - 1] &gt;= A[i]</span></span><br><span class="line"><span class="comment">// 当前元素和前一个元素必须同时交换或不交换</span></span><br><span class="line"><span class="comment">// 1.3 当前元素不交换 dp[i][0] = dp[i - 1][0]</span></span><br><span class="line"><span class="comment">// 1.4 当前元素交换 dp[i][1] = dp[i - 1][1] + 1</span></span><br><span class="line"><span class="comment">// 2. A[i - 1] &gt;= A[i] || B[i - 1] &gt;= B[i]</span></span><br><span class="line"><span class="comment">// 当前元素若不交换则前一元素需要交换, 当前元素若交换则前一元素不能交换</span></span><br><span class="line"><span class="comment">// dp[i][0] = d[i - 1][1]</span></span><br><span class="line"><span class="comment">// dp[i][1] = d[i - 1][0] + 1</span></span><br><span class="line"><span class="comment">// 作为 base case, 第 0 个元素可以交换也可以不交换</span></span><br><span class="line"><span class="comment">// 若不交换 dp[0][0] = 0</span></span><br><span class="line"><span class="comment">// 若交换 dp[0][1] = 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i - <span class="number">1</span>] &lt; A[i] &amp;&amp; B[i - <span class="number">1</span>] &lt; B[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">1</span>] &lt; B[i] &amp;&amp; B[i - <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/" target="_blank" rel="noopener">LCP 07. 传递信息</a></h5><blockquote>
<p>  小朋友<code>A</code>在和<code>ta</code>的小伙伴们玩传信息游戏，游戏规则如下：</p>
<ol>
<li><p>有<code>n</code>名玩家，所有玩家编号分别为<code>0～n-1</code>，其中小朋友<code>A</code>的编号为<code>0</code>；</p>
</li>
<li><p>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如<code>A</code>可以向<code>B</code>传信息，但<code>B</code>不能向<code>A</code>传信息）。</p>
</li>
<li><p>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</p>
<p>给定总玩家数<code>n</code>，以及按<code>[玩家编号，对应可传递玩家编号]</code>关系组成的二维数组<code>relation</code>。返回信息从小<code>A</code> (编号<code>0</code>) 经过<code>k</code>轮传递到编号为<code>n-1</code>的小伙伴处的方案数；若不能到达，返回<code>0</code>。</p>
</li>
</ol>
<p>  <strong>示例 1</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, relation &#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 2</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, relation &#x3D; [[0,2],[2,1]], k &#x3D; 2</span><br><span class="line">输出：0</span><br><span class="line">解释：信息不能从小 A 处经过 2 轮传递到编号 2</span><br></pre></td></tr></table></figure>

<p>  限制：</p>
<ul>
<li>2 &lt;= n &lt;= 10</li>
<li>1 &lt;= k &lt;= 5</li>
<li>1 &lt;=<code>relation.length</code> &lt;= 90, 且 <code>relation[i].length</code> == 2</li>
<li>0 &lt;= <code>relation[i][0], relation[i][1]</code>&lt; n 且 <code>relation[i][0]</code> != <code>relation[i][1]</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较容易想到的是 dfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; r : relation) &#123;</span><br><span class="line">        edges[r[<span class="number">0</span>]].push_back(r[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">int</span> idx, <span class="keyword">int</span> step) &#123;</span><br><span class="line">        <span class="keyword">if</span>(step == k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx == n - <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; to : edges[idx]) &#123;</span><br><span class="line">            dfs(dfs, to, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="comment">// 假设当前我们已经走了 i 步, 所在位置为 j, 那么剩余 k - j 步, 能否到达位置 n - 1</span></span><br><span class="line"><span class="comment">// 仅取决于 [剩余步数 k - i] 和 [边权关系 relation], 与如何到达位置 i 无关</span></span><br><span class="line"><span class="comment">// 对于方案数而言, 如果已经走了 i 步, 所在位置为 j, 到达位置 n - 1 的方案数仅取决于</span></span><br><span class="line"><span class="comment">// [剩余步数 k - i], [边权关系 relation] 和 [花费 i 步到达位置 j 的方案数]</span></span><br><span class="line"><span class="comment">// 以上分析归纳到边界 [走了 0 步, 所在位置 0] 同样成立</span></span><br><span class="line"><span class="comment">// 这就是动态规划中需要满足的 [无后效性]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示走了 i 步, 到达位置 j 的方案数</span></span><br><span class="line"><span class="comment">// 最终要求 dp[k][n - 1], 初始时 dp[0][0] = 1</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][p] for [p, j] in relation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; edge : relation) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = edge[<span class="number">0</span>], dst = edge[<span class="number">1</span>];</span><br><span class="line">            dp[i][dst] += dp[i - <span class="number">1</span>][src];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a></h5><blockquote>
<p>  编写一段程序来查找第<code>n</code>个超级丑数。超级丑数是指其所有质因数都是长度为<code>k</code>的质数列表<code>primes</code>中的正整数。</p>
<p>  <strong>示例</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12, primes &#x3D; [2,7,13,19]</span><br><span class="line">输出: 32 </span><br><span class="line">解释: 给定长度为 4 的质数列表 primes &#x3D; [2,7,13,19]，</span><br><span class="line">前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32]</span><br></pre></td></tr></table></figure>

<p>  <strong>说明</strong>：</p>
<ul>
<li><code>1</code>是任何给定<code>primes</code>的超级丑数；</li>
<li>给定<code>primes</code>中的数字以升序排列。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 set 的去重和有序特性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; uglys;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> prime : primes) &#123;</span><br><span class="line">            uglys.insert(prime * res);</span><br><span class="line">        &#125;</span><br><span class="line">        res = *uglys.begin();</span><br><span class="line">        uglys.erase(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划: 多指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = primes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">su</span><span class="params">(n)</span></span>;</span><br><span class="line">    su[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        su[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            su[i] = min(su[i], primes[j] * su[p[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(su[i] == primes[j] * su[p[j]]) &#123;</span><br><span class="line">                p[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> su[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 263. 丑数</span></span><br><span class="line"><span class="comment">//https://leetcode-cn.com/problems/ugly-number/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> factor : &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        <span class="keyword">while</span>(n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 264. 丑数II</span></span><br><span class="line"><span class="comment">// https://leetcode-cn.com/problems/ugly-number-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 set 的自动排序与降重功能</span></span><br><span class="line"><span class="comment">// 时间复杂度为外围的 n 次循环 O(n)</span></span><br><span class="line"><span class="comment">// 内部 set 的插入和删除操作都是 O(logn)</span></span><br><span class="line"><span class="comment">// 所以时间复杂度总共是 O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度总共为 set 使用的 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; setting;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        setting.insert(res * <span class="number">2</span>);</span><br><span class="line">        setting.insert(res * <span class="number">3</span>);</span><br><span class="line">        setting.insert(res * <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 每次取出最小的丑数用于下一次循环</span></span><br><span class="line">        res = *setting.begin();</span><br><span class="line">        <span class="comment">// 取出来之后它就没用了, 及时剔除</span></span><br><span class="line">        setting.erase(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态规划: 三指针</span></span><br><span class="line"><span class="comment">// p2 代表的是第几个数的 2 倍</span></span><br><span class="line"><span class="comment">// p3 代表的是第几个数的 3 倍</span></span><br><span class="line"><span class="comment">// p5 代表的是第几个数的 5 倍</span></span><br><span class="line"><span class="comment">// 时间复杂度就只有外层的 n 次循环 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(n)</span></span>;</span><br><span class="line">    u[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        u[i] = min(&#123;<span class="number">2</span> * u[p2], <span class="number">3</span> * u[p3], <span class="number">5</span> * u[p5]&#125;);</span><br><span class="line">        <span class="keyword">if</span>(u[i] == <span class="number">2</span> * u[p2]) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u[i] == <span class="number">3</span> * u[p3]) &#123;</span><br><span class="line">            p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u[i] == <span class="number">5</span> * u[p5]) &#123;</span><br><span class="line">            p5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 助你理解一:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段代码两个关键点.</span></span><br><span class="line"><span class="comment">1. 每次对计算出三个丑数并取最小，这里需要计算三个丑数，一定有两个丑数是在上一次中就已经被计算并比较过的, 因为较大所以被筛掉了两个（这两个进入下次比较中）, 留下较小的那个, 并自增一次最小值的下标 i, 使得参与下次计算时能稍微增大, 并同该次比较中淘汰的两个稍大数比较, 经过这样的不断比较 + 迭代, 能保证结果集是按从小到大的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 自增每次的最小丑数值的下标, 这么做一是可以迭代避免重复计算, 从而避免出现重复值, 二是避免遗漏. 因为按照最直接的理解与解法, 每个数都需分别 *2、*3、*5 加入数组, 历经n次，最后再排序，但通过设置三个从 0 开始的下标, 使其对应的值分别只与 2 或 3 或 5 相乘, 而每个下标都有机会迭代, 这样可以保证数组中的每个数实际都是分别与 2、3、5 乘一次, 数组中的前四个数是 1,2,3,5, 后面的数都是由前面的数分别与 2、3、5 相乘计算出来的, 这样也满足了丑数的定义, 并且每次计算的数都是先排序再加入的, 如此可以避免不漏且排序. 而不重是通过三个 if 判断解决的, 因为假如一个数既可通过 *2 得到又可以通过 *3 得到, 此时必然会重复计算并重复加入到数组, 因此此时需要既迭代 2 对应的下标 p2, 也迭代 3 对应的下标 p3, 所以 if 如果换成 if-else, 必然会有大量重复值出现.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 助你理解二:</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">动态规划方法对于三指针的解释令人费解, 实际上这三个指针是用于对三个子序列归并排序的.</span></span><br><span class="line"><span class="comment">1. 令 nums 为升序的全部丑数序列, nums[n - 1] 即为所求, 初始只有一个元素 1, 即 nums[0] 为 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 根据丑数的定义可知, 除 1 外其他丑数都可以通过更小的丑数乘以 2、3、5 得到, 因此由 nums 可生成三个有序丑数子序列 nums_j, j 为 2、3、5. nums_j 元素生成规则为 nums[p_j] * j, p_j 为指向 nums 元素的指针,</span></span><br><span class="line"><span class="comment">对这三个有序丑数子序列进行归并排序可以求得 nums 中的其他元素.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. nums 和三个子序列 nums_j 的元素都是动态生成的, 且生成 nums_j 的规则 nums[p_j] * j 中 j 是固定的, 不必预先创建出三个完整的子序列，只需维护三个指向 nums 的指针 p_j 用于归并排序即可.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 归并排序每生成一个最小丑数 min 时，将 min 追加到 nums 中, 然后生成 min 所在子序列 nums_j 的下一个元素, 即将 p_j 右移，pj++, 注意 min 可能同时存在于多个子序列，需要同时右移 p_j, 避免产生重复元素.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. nums 每追加一个丑数后, pj 只可能右移 1 个位置, 所以不会发生越界的情况.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog_v0/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/blog_v0/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/blog_v0/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog_v0/ZUdtS6UUmrVCKLed/" rel="prev" title="牛客2021年4月15号模拟笔试题">
      <i class="fa fa-chevron-left"></i> 牛客2021年4月15号模拟笔试题
    </a></div>
      <div class="post-nav-item">
    <a href="/blog_v0/LZqUbK3Z1CXKja4I/" rel="next" title="leetcode刷题系列之字符串">
      leetcode刷题系列之字符串 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#64-Minimum-Path-Sum"><span class="nav-number">1.</span> <span class="nav-text">64. Minimum Path Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">2.</span> <span class="nav-text">72. Edit Distance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-number">3.</span> <span class="nav-text">300. Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#354-Russian-Doll-Envelopes"><span class="nav-number">4.</span> <span class="nav-text">354. Russian Doll Envelopes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#494-Target-Sum"><span class="nav-number">5.</span> <span class="nav-text">494. Target Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#91-Decode-Ways、-639-Decode-Ways-II"><span class="nav-number">6.</span> <span class="nav-text">91. Decode Ways、 639. Decode Ways II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#516-Longest-Palindromic-Subsequence"><span class="nav-number">7.</span> <span class="nav-text">516. Longest Palindromic Subsequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1143-Longest-Common-Subsequence"><span class="nav-number">8.</span> <span class="nav-text">1143. Longest Common Subsequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#583-Delete-Operation-for-Two-Strings"><span class="nav-number">9.</span> <span class="nav-text">583. Delete Operation for Two Strings</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><span class="nav-number">10.</span> <span class="nav-text">712. Minimum ASCII Delete Sum for Two Strings</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#368-Largest-Divisible-Subset"><span class="nav-number">11.</span> <span class="nav-text">368. Largest Divisible Subset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">12.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">13.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">14.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#188-Best-Time-to-Buy-and-Sell-Stock-IV"><span class="nav-number">15.</span> <span class="nav-text">188. Best Time to Buy and Sell Stock IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number">16.</span> <span class="nav-text">309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="nav-number">17.</span> <span class="nav-text">714. Best Time to Buy and Sell Stock with Transaction Fee</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#377-Combination-Sum-IV"><span class="nav-number">18.</span> <span class="nav-text">377. Combination Sum IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#322-Coin-Change"><span class="nav-number">19.</span> <span class="nav-text">322. Coin Change</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#518-Coin-Change-2"><span class="nav-number">20.</span> <span class="nav-text">518. Coin Change 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#474-Ones-and-Zeroes"><span class="nav-number">21.</span> <span class="nav-text">474. Ones and Zeroes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#139-Word-Break"><span class="nav-number">22.</span> <span class="nav-text">139. Word Break</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#140-Word-Break-II"><span class="nav-number">23.</span> <span class="nav-text">140. Word Break II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum"><span class="nav-number">24.</span> <span class="nav-text">416. Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#698-Partition-to-K-Equal-Sum-Subsets"><span class="nav-number">25.</span> <span class="nav-text">698. Partition to K Equal Sum Subsets</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#55-Jump-Game"><span class="nav-number">26.</span> <span class="nav-text">55. Jump Game</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#45-Jump-Game-II"><span class="nav-number">27.</span> <span class="nav-text">45. Jump Game II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1306-Jump-Game-III"><span class="nav-number">28.</span> <span class="nav-text">1306. Jump Game III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1345-Jump-Game-IV"><span class="nav-number">29.</span> <span class="nav-text">1345. Jump Game IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#403-Frog-Jump"><span class="nav-number">30.</span> <span class="nav-text">403. Frog Jump</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-Regular-Expression-Matching"><span class="nav-number">31.</span> <span class="nav-text">10. Regular Expression Matching</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#312-Burst-Balloons"><span class="nav-number">32.</span> <span class="nav-text">312. Burst Balloons</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#887-Super-Egg-Drop"><span class="nav-number">33.</span> <span class="nav-text">887. Super Egg Drop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#198-House-Robber"><span class="nav-number">34.</span> <span class="nav-text">198. House Robber</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#213-House-Robber-II"><span class="nav-number">35.</span> <span class="nav-text">213. House Robber II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#337-House-Robber-III"><span class="nav-number">36.</span> <span class="nav-text">337. House Robber III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#740-Delete-and-Earn"><span class="nav-number">37.</span> <span class="nav-text">740. Delete and Earn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">38.</span> <span class="nav-text">53. Maximum Subarray</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number">39.</span> <span class="nav-text">152. Maximum Product Subarray</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1262-Greatest-Sum-Divisible-by-Three"><span class="nav-number">40.</span> <span class="nav-text">1262. Greatest Sum Divisible by Three</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#486-Predict-the-Winner"><span class="nav-number">41.</span> <span class="nav-text">486. Predict the Winner</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#664-Strange-Printer"><span class="nav-number">42.</span> <span class="nav-text">664. Strange Printer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#546-Remove-Boxes"><span class="nav-number">43.</span> <span class="nav-text">546. Remove Boxes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#338-Counting-Bits"><span class="nav-number">44.</span> <span class="nav-text">338. Counting Bits</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible"><span class="nav-number">45.</span> <span class="nav-text">1866. Number of Ways to Rearrange Sticks With K Sticks Visible</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#410-Split-Array-Largest-Sum"><span class="nav-number">46.</span> <span class="nav-text">410. Split Array Largest Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1049-最后一块石头的重量-II"><span class="nav-number">47.</span> <span class="nav-text">1049. 最后一块石头的重量 II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#879-盈利计划"><span class="nav-number">48.</span> <span class="nav-text">879. 盈利计划</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1155-掷骰子的N种方法"><span class="nav-number">49.</span> <span class="nav-text">1155. 掷骰子的N种方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#801-使序列递增的最小交换次数"><span class="nav-number">50.</span> <span class="nav-text">801. 使序列递增的最小交换次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LCP-07-传递信息"><span class="nav-number">51.</span> <span class="nav-text">LCP 07. 传递信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#313-超级丑数"><span class="nav-number">52.</span> <span class="nav-text">313. 超级丑数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/blog_v0/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog_v0/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog_v0/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog_v0/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog_v0/lib/anime.min.js"></script>
  <script src="/blog_v0/lib/velocity/velocity.min.js"></script>
  <script src="/blog_v0/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog_v0/js/utils.js"></script>

<script src="/blog_v0/js/motion.js"></script>


<script src="/blog_v0/js/schemes/pisces.js"></script>


<script src="/blog_v0/js/next-boot.js"></script>




  




  
<script src="/blog_v0/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/blog_v0/js/src/clicklove.js"></script>