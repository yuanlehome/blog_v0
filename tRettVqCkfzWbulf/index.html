<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog_v0/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog_v0/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog_v0/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog_v0/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/blog_v0/css/main.css">


<link rel="stylesheet" href="/blog_v0/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/blog_v0/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="背景知识 IPC对象 内核中用于进程间通信的数据结构，全局可见，如消息队列的msg_queue结构体、信号量的sem_array结构体，共享内存的shmid_kernel结构体。类似于普通文件是通过文件名（文件描述符）进行读写操作，通过IPC key和IPC标识符进行IPC对象的读写操作。  IPC标识符ID 类似于文件描述符fd，可以用一个IPC标识符来引用一个IPC对象，是一个32位整数，是I">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统之进程间通信（含内核实现）">
<meta property="og:url" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="背景知识 IPC对象 内核中用于进程间通信的数据结构，全局可见，如消息队列的msg_queue结构体、信号量的sem_array结构体，共享内存的shmid_kernel结构体。类似于普通文件是通过文件名（文件描述符）进行读写操作，通过IPC key和IPC标识符进行IPC对象的读写操作。  IPC标识符ID 类似于文件描述符fd，可以用一个IPC标识符来引用一个IPC对象，是一个32位整数，是I">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/641.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/dfsgdfg.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/asdfsd.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/image-20210412111846194.png">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/image-20210412120217377.png">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/image-20210412120755697.png">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/3333rtewrfg.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/image-20210412121016593.png">
<meta property="og:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/image-20210412170936487.png">
<meta property="article:published_time" content="2021-03-25T13:35:42.000Z">
<meta property="article:modified_time" content="2021-03-25T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/tRettVqCkfzWbulf/641.jpg">

<link rel="canonical" href="https://yuanlehome.github.io/tRettVqCkfzWbulf/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统之进程间通信（含内核实现） | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog_v0/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog_v0/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog_v0/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog_v0/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog_v0/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog_v0/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/tRettVqCkfzWbulf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统之进程间通信（含内核实现）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 21:35:42" itemprop="dateCreated datePublished" datetime="2021-03-25T21:35:42+08:00">2021-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog_v0/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog_v0/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><ul>
<li><p><code>IPC</code>对象</p>
<p>内核中用于进程间通信的数据结构，全局可见，如消息队列的<code>msg_queue</code>结构体、信号量的<code>sem_array</code>结构体，共享内存的<code>shmid_kernel</code>结构体。类似于普通文件是通过文件名（文件描述符）进行读写操作，通过<code>IPC key</code>和<code>IPC</code>标识符进行<code>IPC</code>对象的读写操作。</p>
</li>
<li><p><code>IPC</code>标识符<code>ID</code></p>
<p>类似于文件描述符<code>fd</code>，可以用一个<code>IPC</code>标识符来引用一个<code>IPC</code>对象，是一个<code>32</code>位整数，是<code>IPC</code>对象的外部名字。返回给用户进程的。</p>
</li>
<li><p><code>IPC key</code>（魔数）<br><code>IPC</code>对象的内部名，是一个独一无二的整数，用来确保<code>IPC</code>对象的唯一性。该整数类型为<code>key_t</code>，在<code>sys/types.h</code>中被定义为长整型。<br>类似于普通文件通过文件名<code>open</code>一个文件，获得文件描述符；<code>IPC</code>对象是<code>get</code>函数根据给定的<code>key</code>去创建一个<code>IPC</code>对象，并返回<code>IPC</code>标识符<code>ID</code>。根据新资源是信号量、消息队列还是共享内存，分别调用<code>semget()</code>、<code>msgget()</code>或者<code>shmget()</code>函数创建<code>IPC</code>资源。</p>
<p>这三个函数的主要目的都是从<code>IPC key</code>（作为第一个参数传递）中导出相应的<code>IPC</code>标识符<code>ID</code>，进程以后就可以使用这个标识符对资源进行访问。如果还没有<code>IPC</code>资源和<code>IPC</code>关键字相关联，就创建一个新的资源。如果一切都顺利，那么函数就返回一个正的<code>IPC</code>标识符，否则，就返回一个错误码。</p>
</li>
</ul>
<a id="more"></a>

<p>在各个独立进程能够访问<strong><code>IPC</code>对象</strong>之前，<code>IPC</code>对象必须在系统内唯一标识。为此，每种<code>IPC</code>结构在创建时分配了一个<code>IPC key</code>（程序员自由分配）。凡知道这个<strong><code>IPC key</code></strong>的各个程序，都能够通过它得到一个标识符<code>ID</code>，进而访问对应的<code>IPC</code>对象。如果独立的应用程序需要彼此通信，则通常需要将该魔数永久地编译到程序中。</p>
<p>在访问<code>IPC</code>对象时，操作系统采用了基于文件访问权限的一个权限系统。每个<code>IPC</code>对象都有一个用户<code>ID</code>和一个组<code>ID</code>，依赖于产生<code>IPC</code>对象的程序在何种<code>UID/GID</code>之下运行。读写权限在初始化时分配。类似于普通的文件，这些控制了<code>3</code>种不同用户类别的访问：所有者、组、其他。</p>
<p><code>IPC</code>在内核中的默认命名空间通过<code>ipc_namespace</code>的静态实例<code>init_ipc_ns</code>实现，每个命名空间都包含如下信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span>* <span class="title">ids</span>[3];</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体中我们更感兴趣的是数组<code>ids</code>。每个数组元素对应于一种<code>IPC</code>机制：共享内存、信号量、消息队列。每个数组项指向一个<code>struct ipc_ids</code>实例，该结构用于跟踪各类别现存的<code>IPC</code>对象。比如，索引<code>0</code>对应的是信号量，其后是消息队列，最后是共享内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc/util.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> in_use;</span><br><span class="line">    <span class="keyword">unsigned</span> short seq;</span><br><span class="line">    <span class="keyword">unsigned</span> short seq_max;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rw_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span> <span class="comment">// 通过类似于基数树的方式管理 内核内部 ID 到指向 kern_ipc_perm 的指针的映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前几个成员保存了有关<code>IPC</code>对象状态的一般信息。</p>
<ul>
<li><code>in_use</code>保存了当前使用中<code>IPC</code>对象的数目。</li>
<li><code>seq</code>和<code>seq_max</code>用于连续产生用户空间<code>IPC</code>标识符<code>ID</code>。<del>计算方式为<code>ID = seq * M + id</code>。<code>M</code>是固定的宏，值为<code>32768</code>，<code>seq</code>被初始化为<code>0</code>，每次产生一个<code>ID</code>后加<code>1</code>，<code>id</code>为内核内部使用的一个数。</del></li>
<li><code>rw_mutex</code>是一个内核信号量。它用于实现信号量操作，避免用户空间中的竞态条件。该互斥量有效地保护了包含信号量值的数据结构。</li>
</ul>
<p>每个<code>IPC</code>对象都由<code>kern_ipc_perm</code>的一个实例表示，并且都有一个<code>IPC</code>标识符<code>ID</code>，<code>ipcs_idr</code>用于将<code>ID</code>关联到指向对应的<code>kern_ipc_perm</code>实例的指针。</p>
<p><code>kern_ipc_perm</code>的成员保存了有关<code>IPC</code>对象的所有者和访问权限等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*int id;*/</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid;</span><br><span class="line">    <span class="keyword">uid_t</span> cuid;</span><br><span class="line">    <span class="keyword">gid_t</span> cgid;</span><br><span class="line">    <span class="keyword">mode_t</span> mode;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code>保存了用户程序用来标识<code>IPC</code>对象的<code>IPC key</code>，<del><code>id</code>就是前面用来计算标识符<code>ID</code>的公式中的<code>id</code></del>。</li>
<li><code>uid</code>和<code>gid</code>分别指定了所有者的用户<code>ID</code>和组<code>ID</code>。<code>cuid</code>和<code>cgid</code>保存了产生信号量的进程的用户<code>ID</code>和组<code>ID</code>。</li>
<li><code>seq</code>是一个序号，在分配<code>IPC</code>对象时使用，和<code>ipc_ids</code>结构中意思相同，为创建该资源是使用的<code>seq</code>。</li>
<li><code>mode</code>保存了位掩码，指定了所有者、组、其他用户的访问权限。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p><strong>数据传输</strong>：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</p>
</li>
<li><p><strong>共享数据</strong>：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p>
</li>
<li><p><strong>通知事件</strong>：一个进程需要向另一个或一组进程发送消息，通知它发生了某种事件（如进程终止时要通知父进程）。</p>
</li>
<li><p><strong>资源共享</strong>：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p>
</li>
<li><p><strong>进程控制</strong>：有些进程希望完全控制另一个进程的运行（如<code>Debug</code>进程）模式，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</li>
</ul>
<p>每个进程的用户地址空间都是独立的，但是内核空间是共享的，所以，进程之间要想相互通信都要经过内核。<code>Linux</code>提供的几种进程间通信方式有管道、消息队列、信号量、信号、共享内存和本地套接字</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道只能单向传输数据，如果要想双向传输数据，需要创建两个管道。管道分为命名管道和匿名管道。</p>
<p><strong>命名管道</strong>的可通过<code>mkfifo</code>命令来创建，并且指定管道名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfifo mypipe</span></span><br></pre></td></tr></table></figure>

<p>命名管道是以文件的方式存在于文件系统中，类型为<code>p</code>。进程之间可以通过这个文件进行通信。它是为了解决下面将要介绍的匿名管道只能用于具有亲缘关系的进程间通信的局限性的。</p>
<p><strong>匿名管道</strong>通过<code>pipe</code>系统调用创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数通过传出参数返回两个文件描述符，<a href="https://mp.weixin.qq.com/s/hLq7Pp8CkJD9B-Xqym50dA" target="_blank" rel="noopener">如果不清楚文件描述符的概念，参考这篇文章</a>。一个是管道读取端描述符<code>fd[0]</code>，一个是管道的写入端描述符<code>fd[1]</code>。匿名管道是只存在内存中的特殊文件，实际上就是内核中的一块缓存。管道传输的数据是无格式的字节流且大小受限。</p>
<img src="641.jpg" alt="Image" style="zoom:50%;" />

<p>通过<code>fork</code>系统调用创建子进程，创建的子进程会复制父进程的文件描述符，这样两个进程就可以通过各自的<code>fd</code>写入和读取同一个管道文件实现跨进程通信了。</p>
<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的<code>fd[0]</code>，只保留写入的<code>fd[1]</code>；</li>
<li>子进程关闭写入的<code>fd[1]</code>，只保留读取的<code>fd[0]</code>；</li>
</ul>
<img src="dfsgdfg.jpg" alt="dfsgdfg" style="zoom:50%;" />

<p>在<code>shell</code>里面执行<code>A | B</code>命令的时候，<code>A</code>进程和<code>B</code>进程都是<code>shell</code>创建出来的子进程，<code>A</code>和<code>B</code>之间不存在父子关系，它俩的父进程都是<code>shell</code>。</p>
<img src="asdfsd.jpg" alt="asdfsd" style="zoom:50%;" />

<p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>
<p>在<code>Linux</code>中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的<code>file</code>结构和<code>VFS</code>的索引节点<code>inode</code>。通过将两个<code>file</code>结构指向同一个临时的<code>VFS</code>索引节点，而这个<code>VFS</code>索引节点又指向一个物理页面而实现的。</p>
<img src="image-20210412111846194.png" alt="image-20210412111846194" style="zoom: 50%;" />

<p>管道是个环形缓冲区，对环形缓冲区的维护，主要是协调好数据读写的两个指针，以及生产者、消费者的休眠时机。环形缓冲区中一个指针用于读数据，另一个用于写数据。当缓冲区已满时，生产者要睡眠，并在睡眠前唤醒消费者，当缓冲区为空时，消费者要睡眠，并在睡眠前唤醒生产者。当缓冲区满或空时，使一方休眠，这是保证数据不丢失的方法。管道其实就是典型的生产者和消费者问题。</p>
<p>管道写函数通过将字节复制到<code>VFS</code>索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。</p>
<p>当写进程向管道中写入时，它利用标准的库函数<code>write()</code>，系统根据库函数传递的文件描述符，可找到该文件的<code>file</code>结构。<code>file</code>结构中指定了用来进行管道专门写操作的函数<code>pipe_write</code>地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查<code>VFS</code>索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p>
<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定。</li>
</ul>
<p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在<code>VFS</code>索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>
<p>管道的读取过程和写入过程类似，通过read系统调用转调用管道专用读操作函数<code>pipe_read</code>。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p>
<p><strong>可以说管道适用于具有亲缘关系的进程间通信</strong>。无论是命名管道还是匿名管道，进程写入的数据都是缓存在内核的内存缓冲区中，读取的时候自然也是从内核的内存缓冲区中读取，因此需要在用户态和内核态之间转换。<strong>因此，管道的通信方式是低效率的，不适合进程间频繁地、大块地交换数据。</strong></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p><strong>消息队列</strong>的通信模式比如说，<code>A</code>进程要给<code>B</code>进程发送消息，<code>A</code>进程把数据放在对应的消息队列后就可以正常返回了，<code>B</code>进程需要的时候再去读取数据就可以了。同理，<code>B</code>进程要给<code>A</code>进程发送消息也是如此。</p>
<p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期根随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。发送者和接收者通过消息队列通信时，无需同时运行，例如，发送进程可以打开一个队列，写入消息，然后结束工作，接收进程在发送者结束之后启动，仍然可以访问队列并（根据消息编号）获取消息。中间的一段时间内消息由内核维护。</p>
<p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，<strong>每个消息都至少分配一个内存页</strong>，同时所有队列所包含的全部消息体的总长度也是有上限。在<code>Linux</code>内核中，会有两个宏定义<code>MSGMAX</code>和<code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时或者另一进程读取内核中的消息数据时，会发生从内核缓冲区拷贝数据到用户缓冲区的过程。</p>
<p><strong>消息队列的实现</strong>：</p>
<p>消息队列使用名为<code>msg_queue</code>的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> q_stime; <span class="comment">// 上一次调用 sgsnd 送消息的时</span></span><br><span class="line">    <span class="keyword">time_t</span> q_rtime; <span class="comment">// 上一次调用 msgrcv 接收消息的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> q_ctime; <span class="comment">// 上一次修改的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes; <span class="comment">/*队列上当前字节数目*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum; <span class="comment">/*队列中的消息数目*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes; <span class="comment">/*队列上最大字节数目*/</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lspid; <span class="comment">/*上一次调用 msgsnd 的 pid */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lrpid; <span class="comment">/*上一次接收消息的 pid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span> <span class="comment">// 消息体链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span> <span class="comment">// 睡眠的接收者链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span> <span class="comment">// 睡眠的发送者链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>q_messages</code>中的各个消息都封装在<code>msg_msg</code>结构体中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type; <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">int</span> m_ts; <span class="comment">/*消息正文长度*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span>* <span class="title">next</span>;</span><span class="comment">// 如果保存的消息超过一个内存页的长度</span></span><br><span class="line">    <span class="comment">/*接下来是实际的消息*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/*接下来是消息的下一部分*/</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<img src="image-20210412120217377.png" alt="image-20210412120217377" style="zoom: 50%;" />

<p>消息正文紧接着该数据结构的实例之后存储。使用next，可以使消息分布到任意数目的页上。在通过消息队列通信时，发送进程和接收进程都可以进入睡眠：如果消息队列已经达到最大容量，则发送者在试图写入消息时会进入睡眠；如果队列中没有消息，那么接收者在试图获取消息时会进入睡眠。</p>
<p>睡眠的发送者放置在<code>msg_queue</code>的<code>q_senders</code>链表中，睡眠的接收者放置在<code>q_receivers</code>链表中，链表元素使用下列数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">tsk</span>;</span> <span class="comment">// 指向休眠进程的进程描述符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">r_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">r_tsk</span>;</span> <span class="comment">// 指向休眠进程的进程描述符</span></span><br><span class="line">    <span class="keyword">int</span> r_mode;</span><br><span class="line">    <span class="keyword">long</span> r_msgtype;</span><br><span class="line">    <span class="keyword">long</span> r_maxsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">volatile</span> <span class="title">r_msg</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="image-20210412120755697.png" alt="image-20210412120755697" style="zoom: 50%;" />

<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>操作系统内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程<code>A</code>和进程<code>B</code>的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p>但是共享内存通信方式带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p>
<img src="3333rtewrfg.jpg" alt="Image" style="zoom: 50%;" />

<p><strong>共享内存的实现</strong>：</p>
<img src="image-20210412121016593.png" alt="image-20210412121016593" style="zoom:50%;" />

<p>同样，在<code>smd_ids</code>全局变量的<code>entries</code>数组中保存了<code>kern_ipc_perm</code>和<code>shmid_kernel</code>的组合，以便管理<code>IPC</code>对象的访问权限。对每个共享内存对象都创建一个伪文件，通过<code>shm_file</code>连接到<code>shmid_kernel</code>的实例。内核使用<code>shm_file-&gt;f_mapping</code>指针访问地址空间对象（<code>struct address_space</code>），用于创建匿名映射。还需要设置所涉及各进程的页表，使得各个进程都能够访问与该<code>IPC</code>对象相关的内存区域。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p>
<p><strong>信号量其实是一个整型的计数器，程序对其访问都是原子操作，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是<strong><code>P</code>操作</strong>，这个操作会把信号量减去<code>-1</code>，相减后如果信号量<code>&lt; 0</code>，则表明资源已被占用，进程需阻塞等待；相减后如果信号量<code>&gt;= 0</code>，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是<strong><code>V</code>操作</strong>，这个操作会把信号量加上<code>1</code>，相加后如果信号量<code>&lt;= 0</code>，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量<code>&gt; 0</code>，则表明当前没有阻塞中的进程；</li>
</ul>
<p><code>P</code>操作是用在进入共享资源之前，<code>V</code>操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>信号量初始化为<code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。信号初始化为<code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程<code>A</code>应在进程<code>B</code>之前执行。</p>
<p><strong>信号量的实现</strong>：</p>
<p><code>sem_queue</code>是一个数据结构，用于将信号量与睡眠进程关联起来，该进程想要执行信号量操作，但目前不允许执行。换句话说，信号量的待决操作列表中，每一项都是该数据结构的实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">next</span>;</span> <span class="comment">/*队列中下一项*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">prev</span>;</span> <span class="comment">/*队列中的前一项，对于第一项有 *(q-&gt;prev) == q*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">sleeper</span>;</span> <span class="comment">/*睡眠的进程*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>* <span class="title">undo</span>;</span> <span class="comment">/*用于撤销的结构*/</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">/*请求信号量操作的进程 ID*/</span></span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/*操作的完成状态*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span>* <span class="title">sma</span> ;</span><span class="comment">/*操作的信号量数组*/</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">/*内部信号量 ID*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>* <span class="title">sops</span>;</span> <span class="comment">/*待决操作数组*/</span></span><br><span class="line">    <span class="keyword">int</span> nsops; <span class="comment">/*操作数目*/</span></span><br><span class="line">    <span class="keyword">int</span> alter; <span class="comment">/*操作是否改变了数组?*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对每个信号量，都有一个队列管理与信号量相关的所有睡眠进程。该队列并未使用内核的标准设施实现（即<code>struct list_head</code>），而是通过<code>next</code>和<code>prev</code>指针手工实现的。</p>
<ul>
<li><code>sleeper</code>是一个指针，指向等待执行信号量操作进程的<code>task_struct</code>实例。</li>
<li><code>pid</code>指定了等待进程的<code>PID</code>。</li>
<li><code>id</code>保存了标识该信号量的<code>ID</code>。</li>
<li><code>sops</code>是一个指针，指向保存待决信号量操作的数组。操作数目（即，数组的长度）在<code>nsops</code>中定义。</li>
<li><code>alter</code>表明操作是否修改信号量的值（例如，状态查询不改变值）。</li>
<li><code>sma</code>保存了一个指针，指向用于管理信号量状态的数据结构的实例。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/*权限，参见ipc.h*/</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">/*最后一次信号量操作的时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime; <span class="comment">/*最后一次修改的时间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">/*指向数组中第一个信号量的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span> <span class="comment">/*需要处理的待决操作*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">sem_pending_last</span>;</span> <span class="comment">/*上一个待决操作*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span> <span class="comment">/*该数组上的撤销请求*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sem_nsems; <span class="comment">/*数组中信号量的数目*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>系统中的每个信号量集合，都对应于该数据结构的一个实例。该实例用于管理集合中的所有信号量（这个信号量集合指的是，每个进程操作信号量时，信号量都有一个值，将这些值组合在这个集合中，由下面要介绍的<code>sem_base</code>指向的数组表示）。</p>
<ul>
<li><p>信号量访问权限保存在我们熟悉的<code>kern_ipc_perm</code>类型的<code>sem_perm</code>成员中。</p>
</li>
<li><p><code>sem_nsems</code>指定了一个用户信号量集合中信号量的数目。</p>
</li>
<li><p><code>sem_base</code>是一个数组，每个数组项描述了集合中的一个信号量。其中保存了当前的信号量值和上一次访问它的进程的<code>PID</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> semval; <span class="comment">// 当前值</span></span><br><span class="line">    <span class="keyword">int</span> sempid; <span class="comment">// 上一次操作进程的 pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sem_otime</code>指定了上一次访问信号量的时间。<code>sem_ctime</code>指定了上次修改信号量值的时间。</p>
</li>
<li><p><code>sem_pending</code>指向待决信号量操作的链表。该链表由<code>sem_queue</code>实例组成。<code>sem_pending_last</code>用于快速访问该链表的最后一个元素，而<code>sem_pending</code>指向链表的起始。</p>
</li>
</ul>
<img src="image-20210412170936487.png" alt="image-20210412170936487" style="zoom: 80%;" />

<p>从当前命名空间获得<code>sem_ids</code>实例开始，内核通过<code>ipcs_idr</code>找到<code>ID</code>到指针的映射，在其中查找所需的<code>kern_ipc_perm</code>实例。<code>kern_ipc_perm</code>项可以转换为<code>sem_array</code>的实例。信号量的当前状态需要通过与另外两个结构的联系获取。</p>
<ul>
<li>待决操作通过<code>sem_queue</code>实例的链表管理。等待操作执行的睡眠进程，也可以通过该链表确定。</li>
<li><code>struct sem</code>实例的数组用于保存集合中各个信号量的值。</li>
</ul>
<p><code>kern_ipc_perm</code>是用来管理<code>IPC</code>对象的数据结构的第一个成员，不止对信号量是这样，消息队列和共享内存对象也是如此。这使得内核可以使用同样的代码检查所有<code>3</code>种对象的访问权限。放在第一个位置还方便转换为<code>sem_array</code>。</p>
<p>每个<code>sem_queue</code>成员包含了一个指针<code>sops</code>，指向<code>sembuf</code>实例的数组，<code>sembuf</code>详细描述了在信号量上将要执行的操作。使用<code>sembuf</code>实例的数组，可以使用一个<code>semctl</code>调用，用于在信号量集合的各个信号量上执行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sem_num; <span class="comment">// 信号量在数组中的索引</span></span><br><span class="line">    short sem_op; <span class="comment">// 信号量操作</span></span><br><span class="line">    short semflg; <span class="comment">// 操作标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它不仅保存了信号量在信号量集合<code>struct sem[]</code>中的索引（<code>sem_num</code>），还有所要进行的操作（<code>sem_op</code>）和一些操作标志（<code>sem_flg</code>）。</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong>在<code>Linux</code>操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过<code>kill -l</code>命令，查看所有的信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>运行在<code>shell</code>终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li><code>Ctrl + C</code>产生<code>SIGINT</code>信号，表示终止该进程；</li>
<li><code>Ctrl + Z</code>产生<code>SIGTSTP</code>信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过<code>kill</code>命令的方式给进程发送信号，但前提需要知道运行中的进程<code>PID</code>号，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kill <span class="number">-9</span> <span class="number">1050</span></span><br></pre></td></tr></table></figure>

<p>表示给<code>PID</code>为<code>1050</code>的进程发送<code>SIGKILL</code>信号，用来立即结束该进程。</p>
<p>所以，信号事件的来源主要有硬件来源（如键盘<code>Cltr + C</code>）和软件来源（如<code>kill</code>命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<ol>
<li><p><strong>执行默认操作</strong>。<code>Linux</code>对每种信号都规定了默认操作，例如，上面列表中的<code>SIGTERM</code>信号，就是终止进程的意思。<code>Core</code>的意思是<code>Core Dump</code>，也即终止进程后，通过<code>Core Dump</code>将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p>
</li>
<li><p><strong>捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
</li>
<li><p><strong>忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即<code>SIGKILL</code>和<code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
</li>
</ol>
<h4 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h4><p>我们先来看看创建<code>socket</code>的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocal)</span></span></span><br></pre></td></tr></table></figure>

<p>三个参数分别代表：</p>
<ul>
<li><code>domain</code>参数用来指定协议族，比如<code>AF_INET</code>用于<code>IPV4</code>、<code>AF_INET6</code>用于<code>IPV6</code>、<code>AF_LOCAL/AF_UNIX</code>用于本机；</li>
<li><code>type</code>参数用来指定通信特性，比如<code>SOCK_STREAM</code>表示的是字节流，对应<code>TCP</code>、<code>SOCK_DGRAM</code>表示的是数据报，对应<code>UDP</code>、<code>SOCK_RAW</code>表示的是原始套接字；</li>
<li><code>protocal</code>参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，<code>protocol</code>目前一般写成<code>0</code>即可；</li>
</ul>
<p>根据创建<code>socket</code>类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现<code>TCP</code>字节流通信：<code>socket</code>类型是<code>AF_INET</code>和<code>SOCK_STREAM</code>；</li>
<li>实现<code>UDP</code>数据报通信：<code>socket</code>类型是<code>AF_INET</code>和<code>SOCK_DGRAM</code>；</li>
<li>实现<strong>本地进程间通信</strong>：「本地字节流<code>socket</code>」类型是<code>AF_LOCAL</code>和<code>SOCK_STREAM</code>，「本地数据报<code>socket</code>」类型是<code>AF_LOCAL</code>和<code>SOCK_DGRAM</code>。另外，<code>AF_UNIX</code>和<code>AF_LOCAL</code>是等价的。</li>
</ul>
<p>本地字节流<code>socket</code>和本地数据报<code>socket</code>在<code>bind</code>的时候，不像<code>TCP</code>和<code>UDP</code>要绑定<code>IP</code>地址和端口，而是<strong>绑定一个本地文件</strong>，这也是它们之间的最大区别。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog_v0/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog_v0/fhQPnKWa9qDDelG3/" rel="prev" title="leetcode刷题系列之队列和栈">
      <i class="fa fa-chevron-left"></i> leetcode刷题系列之队列和栈
    </a></div>
      <div class="post-nav-item">
    <a href="/blog_v0/rakjPpyIOCsd0MoJ/" rel="next" title="面试知识点详细解读之僵尸进程和孤儿进程">
      面试知识点详细解读之僵尸进程和孤儿进程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#背景知识"><span class="nav-number">1.</span> <span class="nav-text">背景知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用场景"><span class="nav-number">2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道"><span class="nav-number">3.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息队列"><span class="nav-number">4.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存"><span class="nav-number">5.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">6.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号"><span class="nav-number">7.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地套接字"><span class="nav-number">8.</span> <span class="nav-text">本地套接字</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/blog_v0/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog_v0/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog_v0/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog_v0/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog_v0/lib/anime.min.js"></script>
  <script src="/blog_v0/lib/velocity/velocity.min.js"></script>
  <script src="/blog_v0/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog_v0/js/utils.js"></script>

<script src="/blog_v0/js/motion.js"></script>


<script src="/blog_v0/js/schemes/pisces.js"></script>


<script src="/blog_v0/js/next-boot.js"></script>




  




  
<script src="/blog_v0/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/blog_v0/js/src/clicklove.js"></script>