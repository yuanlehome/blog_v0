<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog_v0/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog_v0/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog_v0/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog_v0/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/blog_v0/css/main.css">


<link rel="stylesheet" href="/blog_v0/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/blog_v0/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第4部分——二叉树。这里把有代表性的题目发出来，共计36道。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之二叉树">
<meta property="og:url" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第4部分——二叉树。这里把有代表性的题目发出来，共计36道。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/tmp-tree.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/pathsum1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/pathsumii1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/num2tree.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/exx2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/640.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/sdsef.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/444.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/fgfg.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/1266.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/117_sample.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/116_sample.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/sample_1_1709.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/sample_2_1709.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/sum_tree_1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/flaten.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/e4.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/recover1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/recover2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/ex2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/ex1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/tree1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/maximum-binary-tree-1-1.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/maximum-binary-tree-1-2.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/maximum-binary-tree-2-1.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/maximum-binary-tree-2-2.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/maximum-binary-tree-3-1.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/maximum-binary-tree-3-2.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/236_LCA_Binary_1.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/binarytree.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/symtree1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/sample_1_1702.png">
<meta property="og:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/sample_2_1702.png">
<meta property="article:published_time" content="2021-02-08T13:35:42.000Z">
<meta property="article:modified_time" content="2021-02-08T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/tmp-tree.jpg">

<link rel="canonical" href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之二叉树 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog_v0/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog_v0/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog_v0/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog_v0/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog_v0/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog_v0/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之二叉树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-08 21:35:42" itemprop="dateCreated datePublished" datetime="2021-02-08T21:35:42+08:00">2021-02-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog_v0/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>4</code>部分——二叉树。这里把有代表性的题目发出来，共计<code>36</code>道。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
<a id="more"></a>


<h5 id="114-Binary-Tree-Preorder-Traversal"><a href="#114-Binary-Tree-Preorder-Traversal" class="headerlink" title="114. Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">114. Binary Tree Preorder Traversal</a></h5><blockquote>
<p>二叉树的前序遍历。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        TreeNode* node = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                nodes.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></h5><blockquote>
<p>二叉树的中序遍历。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正中序遍历, 即左-中-右</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;        </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆中序遍历, 即右-中-左</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;        </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            <span class="comment">// 右子树依次入栈</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">// 这里去左子树</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal</a></h5><blockquote>
<p>二叉树的后序遍历。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此解法借鉴中序遍历的思路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    TreeNode* preVisited = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        <span class="comment">// 如果待访问节点没有右孩子或者右孩子刚才访问过</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == preVisited) &#123;</span><br><span class="line">            <span class="comment">// 就访问</span></span><br><span class="line">            preVisited = root;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="comment">// 这是为了跳过下次的 while(root) 循环</span></span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 下一个待访问节点一定是刚刚访问节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果待访问节点有右孩子并且右孩子上次没有访问过</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 就去访问右孩子</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此解法借鉴前序遍历的思路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        TreeNode* node = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="comment">// 和前序遍历相反的顺序访问左右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                nodes.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后, 逆序输出就和后序遍历一样</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a></h5><blockquote>
<p>二叉树的层序遍历。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列迭代实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subVector</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            root = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            subVector[i] = root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">                nodes.push(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                nodes.push(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(subVector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助前序遍历的思想, 递归实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 每次递归的时候提供被遍历节点的层级信息</span></span><br><span class="line">    <span class="keyword">auto</span> preOrder = [&amp;](<span class="keyword">auto</span>&amp;&amp; preOrder, TreeNode* root, <span class="keyword">size_t</span> level) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level) &#123;</span><br><span class="line">            res.resize(level);</span><br><span class="line">        &#125;</span><br><span class="line">        res[level - <span class="number">1</span>].push_back(root-&gt;val);</span><br><span class="line">        preOrder(preOrder, root-&gt;left, level);</span><br><span class="line">        preOrder(preOrder, root-&gt;right, level);</span><br><span class="line">    &#125;;</span><br><span class="line">    preOrder(preOrder, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a></h5><blockquote>
<p>给定二叉树的根，返回其最大深度。二叉树的最大深度是指沿着从根节点到最远的叶节点的最长路径的节点数。</p>
<p><strong>Example:</strong></p>
<img src="tmp-tree.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自上到下递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次递归时传递被访问节点的深度信息</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>)&gt; helper = [&amp;](TreeNode* root, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, depth);</span><br><span class="line">        helper(root-&gt;left, <span class="number">1</span> + depth);</span><br><span class="line">        helper(root-&gt;right, <span class="number">1</span> + depth);</span><br><span class="line">    &#125;;</span><br><span class="line">    helper(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a></h5><blockquote>
<p>  给定二叉树的根，返回其最小深度。二叉树的最小深度是指沿着从根节点到最近的叶节点的最短路径的节点数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftMinDepth = minDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightMinDepth = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(leftMinDepth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightMinDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightMinDepth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + leftMinDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + min(leftMinDepth, rightMinDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS 迭代解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        q.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a></h5><blockquote>
<p>给定二叉树的根和一个整数<code>targetSum</code>，如果树具有从根到叶的路径，则沿路径的所有值加起来等于<code>targetSum</code>，则返回<code>true</code>。</p>
<p><strong>Example:</strong></p>
<img src="pathsum1.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下递归</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasPathSum(root-&gt;left, sum - root-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasPathSum(root-&gt;right, sum - root-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a></h5><blockquote>
<p>给定二叉树的根和一个整数<code>targetSum</code>，返回所有从根到叶的路径，其中每个路径的和等于<code>targetSum</code>。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range<code>[0, 5000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p><strong>Example:</strong></p>
<img src="pathsumii1.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target;</span><br><span class="line">    function&lt;<span class="keyword">void</span>((TreeNode*, <span class="keyword">int</span>))&gt; dfs = [&amp;](TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        target.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">// 如果是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(target);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        <span class="comment">// target.pop_back();</span></span><br><span class="line">        <span class="comment">// target.push_back(root-&gt;val);</span></span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        target.pop_back();</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(root, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a></h5><blockquote>
<p>你将获得一棵二叉树，其中每个节点都包含一个整数值。查找路径中节点值总和为给定值的路径数。</p>
<p>该路径无需在根或叶处开始或结束，但必须向下（仅从父节点到子节点移动）。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">       10</span><br><span class="line">      &#x2F;  \</span><br><span class="line">     5   -3</span><br><span class="line">    &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line">&#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等于以从 root 开始的子路径 + ...</span></span><br><span class="line">    <span class="keyword">return</span> rootPathSum(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dfs 求解以从 root 开始的子路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rootPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>)&gt; dfs = [&amp;](TreeNode* root, <span class="keyword">int</span> curSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) &#123;</span><br><span class="line">            curSum += root-&gt;val;</span><br><span class="line">            <span class="comment">// 和上一题 II 不同了</span></span><br><span class="line">            <span class="comment">// 不必等到是叶子节点</span></span><br><span class="line">            <span class="comment">// 只要中间有满足的, 直接增加计数</span></span><br><span class="line">            <span class="keyword">if</span>(targetSum == curSum) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(root-&gt;left, curSum);</span><br><span class="line">            dfs(root-&gt;right, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面纯递归的方法相当于暴力搜索, 时间复杂度为 O(n2)</span></span><br><span class="line"><span class="comment">// 不仅数组中可以用到前缀和, 这里也可以用到, 时间复杂度可以优化到 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping; <span class="comment">// &lt;前缀和, 出现的次数&gt;</span></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>)&gt; dfs = [&amp;](TreeNode* root, <span class="keyword">int</span> curSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) &#123;</span><br><span class="line">            curSum += root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(mapping.count(curSum - sum)) &#123;</span><br><span class="line">                count += mapping[curSum - sum];</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[curSum]++;</span><br><span class="line">            dfs(root-&gt;left, curSum);</span><br><span class="line">            <span class="comment">// mapping[curSum]--;</span></span><br><span class="line">            <span class="comment">// mapping[curSum]++;</span></span><br><span class="line">            dfs(root-&gt;right, curSum);</span><br><span class="line">            mapping[curSum]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="666-Path-Sum-IV"><a href="#666-Path-Sum-IV" class="headerlink" title="666. Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv/" target="_blank" rel="noopener">666. Path Sum IV</a></h5><blockquote>
<p>对于一棵深度小于<code>5</code>的树，可以用一组三位十进制整数来表示。</p>
<p>对于每个整数：</p>
<p>百位上的数字表示这个节点的深度<code>D</code>，<code>1 &lt;= D &lt;= 4</code>。<br>十位上的数字表示这个节点在当前层所在的位置<code>P</code>，<code>1 &lt;= P &lt;= 8</code>。位置编号与一棵满二叉树的位置编号相同。<br>个位上的数字表示这个节点的权值<code>V</code>，<code>0 &lt;= V &lt;= 9</code>。<br>给定一个包含三位整数的升序数组，表示一棵深度小于<code>5</code>的二叉树，请你返回从根到所有叶子结点的路径之和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [113, 215, 221]</span><br><span class="line">输出: 12</span><br><span class="line">解释: </span><br><span class="line">这棵树形状如下:</span><br><span class="line">  3</span><br><span class="line">&#x2F; \</span><br><span class="line">5   1</span><br><span class="line"></span><br><span class="line">路径和 &#x3D; (3 + 5) + (3 + 1) &#x3D; 12.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [113, 221]</span><br><span class="line">输出: 4</span><br><span class="line">解释: </span><br><span class="line">这棵树形状如下: </span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">路径和 &#x3D; (3 + 1) &#x3D; 4.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似于堆排序中将完全二叉树存储在一个向量的思路</span></span><br><span class="line"><span class="comment">// 借助一个哈希表来记录二叉树的每个节点在向量中的索引和其权重的映射</span></span><br><span class="line"><span class="comment">// 每个节点的索引可通过其深度和位置计算出来</span></span><br><span class="line"><span class="comment">// 公式为 i = 2 ^ (depth - 1) + position - 1</span></span><br><span class="line"><span class="comment">// 比如, 根节点 112, depth = 1, position = 1, i = 2 ^ (1 - 1) + 1 - 1 = 1</span></span><br><span class="line"><span class="comment">// 某节点 346, depth = 3, position = 4, i = 2 ^ (3 - 1) + 4 - 1 = 7</span></span><br><span class="line"><span class="comment">// 这样表示之后, 索引为 i 的节点</span></span><br><span class="line"><span class="comment">// 其左孩子索引为 2 * i, 右孩子索引为 2 * i + 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> depth = num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> position = num % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> weight = num % <span class="number">10</span>;</span><br><span class="line">        mapping[<span class="built_in">pow</span>(<span class="number">2</span>, depth - <span class="number">1</span>) + position - <span class="number">1</span>] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += mapping[i];</span><br><span class="line">        <span class="comment">// 到达叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(<span class="number">2</span> * i) == <span class="number">0</span> &amp;&amp; mapping.count(<span class="number">2</span> * i + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            res += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去左子树</span></span><br><span class="line">        dfs(<span class="number">2</span> * i, sum);</span><br><span class="line">        <span class="comment">// 去右子树</span></span><br><span class="line">        dfs(<span class="number">2</span> * i + <span class="number">1</span>, sum);</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a></h5><blockquote>
<p>你将获得只包含<code>0</code>到<code>9</code>的数字的二叉树的根。树中的每条从根到叶的路径都代表一个数字。</p>
<p>例如，从根到叶的路径<code>1 -&gt; 2 -&gt; 3</code>表示数字<code>123</code>。返回所有从根到叶的数字的总和。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range<code>[1, 1000]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 9</code>.</li>
<li>The depth of the tree will not exceed <code>10</code>.</li>
</ul>
<p><strong>Example:</strong></p>
<img src="num2tree.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,9,0,5,1]</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">auto</span>* root, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(dfs, root-&gt;left, num);</span><br><span class="line">        dfs(dfs, root-&gt;right, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. Binary Tree Maximum Path Sum</a></h5><blockquote>
<p>二叉树中的路径是节点序列，其中序列中的每对相邻节点都有一条连接它们的边。 一个节点最多只能出现在序列中一次。 请注意，该路径不需要通过根。路径的路径总和是路径中节点值的总和。</p>
<p>给定二叉树的根，返回任何路径的最大路径总和。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range<code>[1, 3 * 104]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code>.</li>
</ul>
<p><strong>Example:</strong></p>
<img src="exx2.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历思想</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="comment">// 递归函数的定义是返回 [以 root 为首节点] 的最大路径和</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">auto</span>* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以 left 或 right 为首节点的路径和为负数</span></span><br><span class="line">        <span class="comment">// 就不加上它</span></span><br><span class="line">        <span class="comment">// 这样就能保证返回的值是以 root 为首节点的最大路径和</span></span><br><span class="line">        <span class="comment">// 就是说将 root 单节点看作一条路径</span></span><br><span class="line">        <span class="keyword">int</span> leftMaxSum = max(<span class="number">0</span>, dfs(dfs, root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> rightMaxSum = max(<span class="number">0</span>, dfs(dfs, root-&gt;right));</span><br><span class="line">        <span class="comment">// 计算 [经过] root 的最大路径和</span></span><br><span class="line">        <span class="comment">// 这样, 通过递归的过程, 保证会分别计算经过每一个节点的最大路径和</span></span><br><span class="line">        res = max(res, leftMaxSum + root-&gt;val + rightMaxSum);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(leftMaxSum, rightMaxSum);</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h5><blockquote>
<p>给定两个整数数组<code>preorder</code>和<code>inorder</code>，其中<code>preorder</code>是二叉树的前序遍历，而<code>inorder</code>是同一树的中序遍历，构造并返回二叉树。</p>
<img src="640.jpg" alt="640" style="zoom: 50%;" />

<img src="sdsef.jpg" alt="sdsef" style="zoom: 50%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道前序遍历的首元素就是树的根</span></span><br><span class="line"><span class="comment">// 其在中序遍历的位置的左边所有元素构成左子树, 右边所有元素构成右子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 定位 rootVal 在中序遍历中的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = inStart;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= inEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算左子树节点数量</span></span><br><span class="line">        <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">        root-&gt;left = build(build, preStart + <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(build, preStart + leftSize + <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> build(build, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用一个哈希表存储节点值在中序遍历数组中的索引</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        mapping[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> rootIndex, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[rootIndex];</span><br><span class="line">        <span class="keyword">int</span> index = mapping[rootVal];</span><br><span class="line">        <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的根节点在当前根节点位置 + 1 的位置</span></span><br><span class="line">        root-&gt;left = build(build, rootIndex + <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点在当前根节点位置 + 左子树长度 + 1 的位置</span></span><br><span class="line">        root-&gt;right = build(build, rootIndex + leftSize + <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 因为每次我们只是需要得到节点值在中序遍历数组中的索引</span></span><br><span class="line">    <span class="comment">// 现在我们已经预存储了节点值到索引的映射, 参数中就不需要中序遍历数组了</span></span><br><span class="line">    <span class="comment">// 并且左右树根节点的值在前序遍历数组中的位置可以通过当前根节点的位置和左子树的长度来确定</span></span><br><span class="line">    <span class="keyword">return</span> build(build, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h5><blockquote>
<p>给定两个整数数组<code>postorder</code>和<code>inorder</code>，其中<code>postorder</code>是二叉树的后序遍历，而<code>inorder</code>是同一树的中序遍历，构造并返回二叉树。</p>
<img src="444.jpg" alt="444" style="zoom: 50%;" />

<img src="fgfg.jpg" alt="fgfg" style="zoom: 50%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道后序遍历的尾元素就是树的根</span></span><br><span class="line"><span class="comment">// 其在中序遍历的位置的左边所有元素构成左子树</span></span><br><span class="line"><span class="comment">// 右边所有元素构成右子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> rootIndex, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历尾元素就是根</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[rootIndex];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 定位根在中序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 一定存在</span></span><br><span class="line">        <span class="comment">// 这里有一个特殊情况 inStart == inEnd</span></span><br><span class="line">        <span class="comment">// 出现这种情况 index 应该等于 inStart == inEnd</span></span><br><span class="line">        <span class="comment">// 递归基可以处理</span></span><br><span class="line">        <span class="keyword">int</span> index = inStart;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= inEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算右子树的节点数</span></span><br><span class="line">        <span class="keyword">int</span> rightSize = inEnd - index;</span><br><span class="line">        <span class="comment">// 左子树的根节点在当前根节点位置 - 右子树长度 - 1 的位置</span></span><br><span class="line">        root-&gt;left = build(build, rootIndex - rightSize - <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点在当前根节点位置 - 1 的位置</span></span><br><span class="line">        root-&gt;right = build(build, rootIndex - <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> build(build, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用一个哈希表存储节点值在中序遍历数组中的索引</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++) &#123;</span><br><span class="line">        mapping[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> rootIndex, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[rootIndex];</span><br><span class="line">        <span class="keyword">int</span> index = mapping[rootVal];</span><br><span class="line">        <span class="keyword">int</span> rightSize = inEnd - index;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的根节点在当前根节点位置 - 右子树长度 - 1 的位置</span></span><br><span class="line">        root-&gt;left = build(build, rootIndex - rightSize - <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点在当前根节点位置 - 1 的位置</span></span><br><span class="line">        root-&gt;right = build(build, rootIndex - <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 因为每次我们只是需要得到节点值在中序遍历数组中的索引</span></span><br><span class="line">    <span class="comment">// 现在我们已经预存储了节点值到索引的映射, 参数中就不需要中序遍历数组了</span></span><br><span class="line">    <span class="comment">// 左右树根节点的值在前序遍历数组中的位置可以通过当前根节点的位置和右子树的长度来确定</span></span><br><span class="line">    <span class="keyword">return</span> build(build, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">889. Construct Binary Tree from Preorder and Postorder Traversal</a></h5><blockquote>
<p>返回与给定的前序和后序遍历匹配的任意二叉树。二叉树中的值是不同的正整数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然有些情况不能确定一棵唯一的二叉树</span></span><br><span class="line"><span class="comment">// 但我们决定左右子树的规则固定即可</span></span><br><span class="line"><span class="comment">// 首先注意到前序遍历的首元素为树的根</span></span><br><span class="line"><span class="comment">// 首元素的下一个元素可能为其左子树的根, 也可能为其右子树的根</span></span><br><span class="line"><span class="comment">// 但我们始终把它认定为左子树的根</span></span><br><span class="line"><span class="comment">// 接下来就是在后序遍历中定位到 前序遍历首元素的下一个元素 的位置</span></span><br><span class="line"><span class="comment">// 这个位置左边的就是左子树所有元素 (包括这个位置上的元素, 实际上它是左子树的根)</span></span><br><span class="line"><span class="comment">// 右边的就是右子树所有元素 (除了末元素, 因为它是当前树的根啊)</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pre.size();</span><br><span class="line">    function&lt;TreeNode*(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; construct = [&amp;](<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 这个条件判断非常重要</span></span><br><span class="line">        <span class="comment">// 如果 preStart == preEnd</span></span><br><span class="line">        <span class="comment">// 下面的 index 就会因为找不到而很大 为 postEnd</span></span><br><span class="line">        <span class="comment">// 导致错误地计算出很大的 leftSize</span></span><br><span class="line">        <span class="comment">// 这种情况递归基处理不了</span></span><br><span class="line">        <span class="keyword">if</span>(preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位到左子树的根在后序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 此时保证至少会有该元素, 也就是说 pre[preStart + 1] 在后序遍历中一定存在</span></span><br><span class="line">        <span class="keyword">int</span> index = postStart;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; postEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(post[index] == pre[preStart + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = index - postStart + <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = construct(preStart + <span class="number">1</span>, preStart + leftSize, postStart, index);</span><br><span class="line">        root-&gt;right = construct(preStart + leftSize + <span class="number">1</span>, preEnd, index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> construct(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">1008. Construct Binary Search Tree from Preorder Traversal</a></h5><blockquote>
<p>给定一个整数已排序数组，该数组表示二叉搜索树的前序遍历结果，请构造该<code>BST</code>树并返回其根。</p>
<p>可以确保始终可以找到满足测试用例要求的<code>BST</code>。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 100</code>.</li>
<li><code>1 &lt;= preorder[i] &lt;= 108</code>.</li>
<li>All the values of <code>preorder</code> are <strong>unique</strong>.</li>
</ul>
<p><strong>Example:</strong></p>
<img src="1266.png" alt="img" style="zoom: 50%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先可以确定前序遍历的首元素为树的根</span></span><br><span class="line"><span class="comment">// 其左子树的所有元素都小于首元素</span></span><br><span class="line"><span class="comment">// 其右子树的所有元素都大于首元素</span></span><br><span class="line"><span class="comment">// 所以, 我们接下来只要确定数组中第一个大于首元素的值的位置</span></span><br><span class="line"><span class="comment">// 就能够直到左子树和右子树的元素范围</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">    function&lt;TreeNode*(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根为首元素</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 找到第一个大于首元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> index  = preStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= preEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[index] &gt; rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里, 有两种情况</span></span><br><span class="line">        <span class="comment">// 1. 左子树为空, 此时 index 应该为 prepreStart + 1</span></span><br><span class="line">        <span class="comment">// 2. 右子树为空, 此时 index 应该为 preEnd + 1</span></span><br><span class="line">        <span class="comment">// 无论哪一种情况, 递归进去之后, 递归基都可以处理</span></span><br><span class="line">        root-&gt;left = build(preStart + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(index, preEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode" class="headerlink" title="117. Populating Next Right Pointers in Each Node II - LeetCode"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II - LeetCode</a></h5><blockquote>
<p>填充二叉树的每个节点下一个指针以指向其下一个右节点。 如果没有下一个右节点，则下一个指针应设置为<code>NULL</code>。</p>
<p>最初，所有下一个指针都设置为<code>NULL</code>。</p>
<img src="117_sample.png" alt="img" style="zoom: 50%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node *left;</span></span><br><span class="line"><span class="comment">    Node *right;</span></span><br><span class="line"><span class="comment">    Node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用辅助节点的迭代式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    Node helper;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        Node* last = &amp;helper;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">                last-&gt;next = cur-&gt;left;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) &#123;</span><br><span class="line">                last-&gt;next = cur-&gt;right;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = helper.next;</span><br><span class="line">        helper.next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列的迭代式解法(层序遍历)</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(cur) &#123;</span><br><span class="line">        nodes.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = nodes.size(); sz &gt; <span class="number">0</span>; sz--) &#123;</span><br><span class="line">            cur = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            cur-&gt;next = sz &gt; <span class="number">1</span> ? nodes.front() : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">                nodes.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) &#123;</span><br><span class="line">                nodes.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果给定的二叉树是棵<strong>完美二叉树</strong>：<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></p>
<img src="116_sample.png" alt="img" style="zoom: 50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对完美二叉树的递归式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归函数的定义就是将 p 和 q 两节点相连</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(Node*, Node*)&gt; helper = [&amp;](Node* p, Node* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        helper(p-&gt;left, p-&gt;right);</span><br><span class="line">        helper(q-&gt;left, q-&gt;right);</span><br><span class="line">        helper(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;;</span><br><span class="line">    helper(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree</a></h5><blockquote>
<p>给定二叉树的根，确定它是否是有效的二叉搜索树。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须将对上层节点的约束传递给下层节点</span></span><br><span class="line">    <span class="comment">// 限定以 root 为根的子树节点必须满足 min-&gt;val &lt; root.val &lt; max-&gt;val</span></span><br><span class="line">    function&lt;<span class="keyword">bool</span>(TreeNode*, TreeNode*, TreeNode*)&gt; helper = [&amp;](TreeNode* root, TreeNode* min, TreeNode* max) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min &amp;&amp; root-&gt;val &lt;= min-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max &amp;&amp; root-&gt;val &gt;= max-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这时 left 节点的最大就是 root, right 节点的最小值就是 root</span></span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, min, root) &amp;&amp; helper(root-&gt;right, root, max);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1373-Maximum-Sum-BST-in-Binary-Tree"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree" class="headerlink" title="1373. Maximum Sum BST in Binary Tree"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. Maximum Sum BST in Binary Tree</a></h5><blockquote>
<p>给定二叉树的根，找出所有是<code>BST</code>的子树，分别计算这些子树的所有节点值的和， 返回其中的最大值。</p>
<p>二叉搜索树的定义如下：</p>
<p>任意节点的左子树中的键值都小于此节点的键值。<br>任意节点的右子树中的键值都大于此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p>
<p><strong>Example 1:</strong></p>
<img src="sample_1_1709.png" alt="img" style="zoom: 80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="sample_2_1709.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,3,null,1,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递归函数返回值依次是</span></span><br><span class="line">    <span class="comment">// 1. 以 root 为根的 BST 子树节点值的总和, 如果其不是 BST, 此值为 0</span></span><br><span class="line">    <span class="comment">// 2. 以 root 为根的树中节点的最小值, 如果其不是 BST, 此值为 INT_MIN</span></span><br><span class="line">    <span class="comment">// 3. 以 root 为根的树中节点的最大值, 如果其不是 BST, 此值为 INT_MAX </span></span><br><span class="line">    <span class="keyword">auto</span> postOrder = [&amp;res](<span class="keyword">auto</span>&amp; postOrder, TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="number">0</span>, INT_MAX, INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [leftSum, leftMinVal, leftMaxVal] = postOrder(postOrder, root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [rightSum, rightMinVal, rightMaxVal] = postOrder(postOrder, root-&gt;right);</span><br><span class="line">        <span class="comment">// 如果当前节点的左子树中节点的最大值比当前节点还大</span></span><br><span class="line">        <span class="comment">// 或者当前节点的右子树中节点的最小值比当前节点还小</span></span><br><span class="line">        <span class="comment">// 以当前节点为根的子树就不是 BST</span></span><br><span class="line">        <span class="comment">// 因此总和为 0</span></span><br><span class="line">        <span class="comment">// 最小值为 INT_MIN 以致于右子树中包含此树的树也被认定为非 BST</span></span><br><span class="line">        <span class="comment">// 最大值为 INT_MAX 以致于左子树中包含此树的树也被认定为非 BST</span></span><br><span class="line">        <span class="keyword">if</span>(leftMaxVal &gt;= root-&gt;val || rightMinVal &lt;= root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="number">0</span>, INT_MIN, INT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时, 以当前节点为根的子树是 BST</span></span><br><span class="line">        <span class="comment">// 计算此树的总和并更新最大值</span></span><br><span class="line">        <span class="keyword">int</span> sum = leftSum + root-&gt;val + rightSum;</span><br><span class="line">        res = max(res, sum);</span><br><span class="line">        <span class="comment">// 最后还要返回以当前节点为根的子树的信息</span></span><br><span class="line">        <span class="comment">// 其总和就为 sum</span></span><br><span class="line">        <span class="comment">// 1. 当前节点有可能是叶子节点或者只有一颗子树</span></span><br><span class="line">            <span class="comment">// 所以最小值为当前节点的值和左子树中最小的值相比取小者</span></span><br><span class="line">            <span class="comment">// 最大值为当前节点的值和右子树中最大的值相比取大者</span></span><br><span class="line">            <span class="comment">// 因为 if(!root) return &#123;0, INT_MAX, INT_MIN&#125;; 语句</span></span><br><span class="line">            <span class="comment">// 保证了左子树中最小的值为 INT_MAX, 右子树中最大的值为 INT_MIN</span></span><br><span class="line">            <span class="comment">// 所以比较的结果肯定是 root-&gt;val</span></span><br><span class="line">        <span class="comment">// 2. 当前节点有两棵子树, 那么比较的结果肯定不是 root-&gt;val (这是 BST 的规则!)</span></span><br><span class="line">        <span class="keyword">return</span> make_tuple(sum, min(root-&gt;val, leftMinVal), max(root-&gt;val, rightMaxVal));</span><br><span class="line">    &#125;;</span><br><span class="line">    postOrder(postOrder, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make_tuple(isBST, sumOfBST, minVal, maxVal)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> post = [&amp;](<span class="keyword">auto</span>&amp;&amp; post, <span class="keyword">auto</span>&amp;&amp; root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 空树也是 BST</span></span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="literal">true</span>, <span class="number">0</span>, INT_MAX, INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; [l_isBST, l_sumOfBST, l_minVal, l_maxVal] = post(post, root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; [r_isBST, r_sumOfBST, r_minVal, r_maxVal] = post(post, root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(!l_isBST || !r_isBST || root-&gt;val &lt;= l_maxVal || root-&gt;val &gt;= r_minVal) &#123;</span><br><span class="line">            <span class="comment">// 不是 BST 的话, 其他值都无所谓了</span></span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = l_sumOfBST + root-&gt;val + r_sumOfBST;</span><br><span class="line">        res = max(res, sum);</span><br><span class="line">        <span class="keyword">return</span> make_tuple(<span class="literal">true</span>, sum, min(root-&gt;val, l_minVal), max(root-&gt;val, r_maxVal));</span><br><span class="line">    &#125;;</span><br><span class="line">    post(post, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree</a></h5><blockquote>
<p>序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接链接进行传输，以便稍后在相同或另一台计算机环境中进行重构。</p>
<p>设计一种用于对二叉树进行序列化和反序列化的算法。 序列化和反序列化算法的工作方式没有任何限制。 你只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前序遍历解法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        serialize(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            res += <span class="string">"# "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">        serialize(root-&gt;left, res);</span><br><span class="line">        serialize(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">stringstream</span>&amp; ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ss) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        ss &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(temp));</span><br><span class="line">        root-&gt;left = deserialize(ss);</span><br><span class="line">        root-&gt;right = deserialize(ss);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 后序遍历解法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        serialize(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; encoded;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, s, <span class="string">' '</span>)) &#123;</span><br><span class="line">            encoded.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            res += <span class="string">"# "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serialize(root-&gt;left, res);</span><br><span class="line">        serialize(root-&gt;right, res);</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; encoded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(encoded.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = encoded.back();</span><br><span class="line">        encoded.pop_back();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(s));</span><br><span class="line">        <span class="comment">// 后序遍历需要先构造右孩子, 再构造左孩子</span></span><br><span class="line">        root-&gt;right = deserialize(encoded);</span><br><span class="line">        root-&gt;left = deserialize(encoded);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 层序遍历解法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> encoded;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                encoded += to_string(node-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                encoded += <span class="string">"# "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> encoded;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> nodeVal;</span><br><span class="line">        ss &gt;&gt; nodeVal;</span><br><span class="line">        <span class="keyword">if</span>(nodeVal == <span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(nodeVal));</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            TreeNode* root = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(ss &gt;&gt; nodeVal) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nodeVal != <span class="string">"#"</span>) &#123;</span><br><span class="line">                    root-&gt;left = <span class="keyword">new</span> TreeNode(stoi(nodeVal));</span><br><span class="line">                    q.push(root-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss &gt;&gt; nodeVal) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nodeVal != <span class="string">"#"</span>) &#123;</span><br><span class="line">                    root-&gt;right = <span class="keyword">new</span> TreeNode(stoi(nodeVal));</span><br><span class="line">                    q.push(root-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="653. Two Sum IV - Input is a BST"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST</a></h5><blockquote>
<p>给定一个二叉搜索树和一个目标数，如果<code>BST</code>中存在两个元素的总和等于给定的目标数，则返回<code>true</code>。</p>
<p><strong>Example:</strong></p>
<img src="sum_tree_1.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1 基本思想都是借助 BST 的中序遍历结果是升序排列的, 然后借助双指针搜索即可</span></span><br><span class="line"><span class="comment">// 方法 2 无论使用什么遍历 (递归或迭代), 都借助哈希表在遍历的过程中记录已经出现的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">auto</span> helper = [&amp;](<span class="keyword">auto</span>&amp;&amp; helper, <span class="keyword">auto</span> root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(setting.count(k - root-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setting.insert(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> helper(helper, root-&gt;left) || helper(helper, root-&gt;right);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> helper(helper, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List</a></h5><blockquote>
<p>给定二叉树的根，将树展平为“链表”：“链表”应使用相同的<code>TreeNode</code>类，其中右子指针指向列表中的下一个节点，而左子指针始终为<code>null</code>。</p>
<p>“链表”的顺序应与二叉树的前序遍历顺序相同。</p>
<img src="flaten.jpg" alt="img" style="zoom: 67%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归思想: 相信递归函数的定义并毫不怀疑的去调用它!</span></span><br><span class="line"><span class="comment">// 此例中, void flatten(TreeNode* root) 函数的定义就是将 root 平展</span></span><br><span class="line"><span class="comment">// 只需要注意递归基的处理就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        <span class="comment">// 此时左右两棵子树都已经 flatten 完毕了</span></span><br><span class="line">        TreeNode* temp = root-&gt;right; <span class="comment">// 备份右子树</span></span><br><span class="line">        root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 1. 将右孩子指针指向左子树, 随后左孩子指针置空</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 沿着新右指针一直往前走, 定位到尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(root &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 将尾节点指向右子树</span></span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1</span></span><br><span class="line"><span class="comment">   / \</span></span><br><span class="line"><span class="comment">  2   5</span></span><br><span class="line"><span class="comment"> / \   \</span></span><br><span class="line"><span class="comment">3   4   6</span></span><br><span class="line"><span class="comment">// 将 1 的左子树插入到右子树的地方</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2         5</span></span><br><span class="line"><span class="comment">     / \         \</span></span><br><span class="line"><span class="comment">    3   4         6</span></span><br><span class="line"><span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">     / \</span></span><br><span class="line"><span class="comment">    3   4</span></span><br><span class="line"><span class="comment">         \</span></span><br><span class="line"><span class="comment">          5</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            6</span></span><br><span class="line"><span class="comment">// 将 2 的左子树插入到右子树的地方</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">       \</span></span><br><span class="line"><span class="comment">        3       4</span></span><br><span class="line"><span class="comment">                 \</span></span><br><span class="line"><span class="comment">                  5</span></span><br><span class="line"><span class="comment">                   \</span></span><br><span class="line"><span class="comment">                    6</span></span><br><span class="line"><span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">       \</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">         \</span></span><br><span class="line"><span class="comment">          4</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            5</span></span><br><span class="line"><span class="comment">             \</span></span><br><span class="line"><span class="comment">              6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre = cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right) &#123;</span><br><span class="line">                pre = pre-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">            pre-&gt;right = cur-&gt;right;</span><br><span class="line">            <span class="comment">// 将左子树插入到右子树的地方</span></span><br><span class="line">            cur-&gt;right = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑下一个节点</span></span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a><a href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" target="_blank" rel="noopener">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a></h5><blockquote>
<p>给定一个原始树和一个克隆树，克隆树是原始树的副本。并给出对原始树中某目标节点的引用。</p>
<p>返回对克隆树中相同节点的引用。</p>
<p>请注意，不允许您更改两个树或目标节点中的任何一个，并且答案必须是对克隆树中节点的引用。</p>
<p>注意：你的解答要适用于在树上允许有重复的值的情况。</p>
<p><img src="e4.png" alt="img"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树上允许有重复的值意味着不能通过比较节点的值来返回目标节点</span></span><br><span class="line"><span class="comment">// 题目已经给出保证 original cloned target 都不为 null</span></span><br><span class="line"><span class="comment">// 直接对两棵树同步遍历</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">getTargetCopy</span><span class="params">(TreeNode* original, TreeNode* cloned, TreeNode* target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!original) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(original == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先在左子树中找</span></span><br><span class="line">    TreeNode* found = getTargetCopy(original-&gt;left, cloned-&gt;left, target);</span><br><span class="line">    <span class="comment">// 没找到再去右子树中找</span></span><br><span class="line">    <span class="keyword">if</span>(!found) &#123;</span><br><span class="line">        found = getTargetCopy(original-&gt;right, cloned-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. Recover Binary Search Tree</a></h5><blockquote>
<p>给定一个二叉搜索树的根节点，恰好树中的两个节点错误地交换了。 在不更改其结构的前提下，恢复这棵二叉搜索树。</p>
<table>
<thead>
<tr>
<th align="center">Example 1</th>
<th align="center">Example 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="recover1.jpg" alt="img"></td>
<td align="center"><img src="recover2.jpg" alt="img"></td>
</tr>
</tbody></table>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,3,null,null,2]</span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line">Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,null,2]</span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line">Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：使用<code>O(n)</code>空间复杂度的解决方案非常简单。 你能设计一个<code>O(1)</code>空间解决方案吗？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道, BST 的中序遍历是有序的</span></span><br><span class="line"><span class="comment">// 然后注意到, 如果树中有两个节点被交换了</span></span><br><span class="line"><span class="comment">// 在中序遍历序列中必然会出现逆序对 (可能一对, 也可能两对)</span></span><br><span class="line"><span class="comment">// 一对的情况是被交换的两个节点在中序遍历序列中相邻</span></span><br><span class="line"><span class="comment">// 此时我们有两个指针来分别定位这一逆序对的两个节点</span></span><br><span class="line"><span class="comment">// 交换它们的值即可</span></span><br><span class="line"><span class="comment">// 被交换的两个节点不相邻就会出现两对逆序对的情况</span></span><br><span class="line"><span class="comment">// 此时, 有一个指针定位前一个逆序对的第一个节点</span></span><br><span class="line"><span class="comment">// 另一个指针定位后一个逆序对的第二个节点</span></span><br><span class="line"><span class="comment">// 交换它们的值即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这题要学会如何跟踪遍历过程中当前节点的前一个节点的技术</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定位逆序对的第一个节点</span></span><br><span class="line">    TreeNode* first = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 定位逆序对的第二个节点</span></span><br><span class="line">    TreeNode* second = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 始终指向当前访问节点的前一个节点</span></span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> inorder = [&amp;](<span class="keyword">auto</span>&amp;&amp; inorder, <span class="keyword">auto</span>* cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(inorder, cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;val &gt; cur-&gt;val) &#123;</span><br><span class="line">            <span class="comment">// 如果为空, 说明遇到的是第一个逆序对</span></span><br><span class="line">            <span class="comment">// 当前节点是逆序对的第二个节点</span></span><br><span class="line">            <span class="comment">// 第一个节点由 pre 指出, 更新 first</span></span><br><span class="line">            <span class="comment">// 如果不为空, 说明遇到的是第二个逆序对</span></span><br><span class="line">            <span class="comment">// 就不更新 first, 因为我们定位第二个逆序对的第一个节点没有用</span></span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                first = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是第几个逆序对</span></span><br><span class="line">            <span class="comment">// second 都指向逆序对的第二个节点</span></span><br><span class="line">            second = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持续跟踪前一个节点</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        inorder(inorder, cur-&gt;right);</span><br><span class="line">    &#125;;</span><br><span class="line">    inorder(inorder, root);</span><br><span class="line">    swap(first-&gt;val, second-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="687-Longest-Univalue-Path"><a href="#687-Longest-Univalue-Path" class="headerlink" title="687. Longest Univalue Path"></a><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. Longest Univalue Path</a></h5><blockquote>
<p>给定二叉树的根，返回最长路径的长度，其中路径中的每个节点都具有相同的值。 此路径可能会也可能不会通过根。</p>
<p>两个节点之间的路径长度由它们之间的边数表示。</p>
<p><strong>Example 1:</strong></p>
<img src="ex2.jpg" alt="img" style="zoom: 67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,4,5,4,4,5]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<img src="ex1.jpg" alt="img" style="zoom: 67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,5,1,1,5]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPath = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 该递归函数的定义就是返回以 root 为起点的符合条件的路径的最大长度</span></span><br><span class="line">    <span class="keyword">auto</span> post = [&amp;](<span class="keyword">auto</span>&amp;&amp; post, <span class="keyword">auto</span> cur) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftMax = post(post, cur-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightMax = post(post, cur-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> LeftMaxFromRoot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMaxFromRoot = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点的值与其左孩子的值相等</span></span><br><span class="line">    	<span class="comment">// 那么它就可以和其左孩子的路径连在一块, 路径长度 +1</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            LeftMaxFromRoot = leftMax + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的值与其右孩子的值相等</span></span><br><span class="line">    	<span class="comment">// 那么它就可以和其右孩子的路径连在一块, 路径长度 +1</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            rightMaxFromRoot = rightMax + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这两条路径是不一样的</span></span><br><span class="line">        maxPath = max(maxPath, LeftMaxFromRoot + rightMaxFromRoot);</span><br><span class="line">        <span class="comment">// 而以 root 为起点的符合条件的路径的最大长度为这两条路径的较大者</span></span><br><span class="line">        <span class="keyword">return</span> max(LeftMaxFromRoot, rightMaxFromRoot);</span><br><span class="line">    &#125;;</span><br><span class="line">    post(post, root);</span><br><span class="line">    <span class="keyword">return</span> maxPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. Maximum Binary Tree</a></h5><blockquote>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ol>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ol>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>All integers in <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<p><strong>Example:</strong></p>
<img src="tree1.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">Output: [6,3,5,null,2,0,null,null,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造闭区间 [lo, hi] 内的元素</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt; hi) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 找到最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = findMax(nums, lo, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 另外, 装逼的话, 获取数组中最大元素的索引可以这样写</span></span><br><span class="line"><span class="comment">    int maxIndex = distance(nums.begin(),</span></span><br><span class="line"><span class="comment">    						max_element(nums.begin() + lo, nums.begin() + hi + 1));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以最大值为根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">    <span class="comment">// 左子树为最大值左边的</span></span><br><span class="line">    root-&gt;left = construct(nums, lo, maxIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 右子树为最大值右边的</span></span><br><span class="line">    root-&gt;right = construct(nums, maxIndex + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; maxVal)</span><br><span class="line">        &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a><a href="https://leetcode.com/problems/maximum-binary-tree-ii/" target="_blank" rel="noopener">998. Maximum Binary Tree II</a></h5><blockquote>
<p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p>
<p>给出最大树的根节点<code>root</code>。</p>
<p>就像之前的<code>654. Maximum Binary Tree</code>问题那样，给定的树是从列表<code>A</code>递归地使用下述<code>Construct(A)</code>例程构造的：</p>
<p>如果<code>A</code>为空，返回<code>null</code><br>否则，令<code>A[i]</code>作为<code>A</code>的最大元素。创建一个值为<code>A[i]</code>的根节点<code>root</code><br><code>root</code>的左子树将被构建为<code>Construct([A[0], A[1], ..., A[i-1]])</code><br><code>root</code>的右子树将被构建为<code>Construct([A[i+1], A[i+2], ..., A[A.length - 1]])</code><br>返回<code>root</code><br>请注意，我们这里没有直接给定<code>A</code>，只有一个根节点<code>root = Construct(A)</code>.</p>
<p>假设<code>B</code>是<code>A</code>的副本，并在末尾附加值<code>val</code>。题目数据保证B中的值是不同的。返回<code>Construct(B)</code>。</p>
<p><strong>Example 1:</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="maximum-binary-tree-1-1.png" alt="img"></td>
<td><img src="maximum-binary-tree-1-2.png" alt="img"></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,1,3,null,null,2], val &#x3D; 5</span><br><span class="line">Output: [5,4,null,1,3,null,null,2]</span><br><span class="line">Explanation: A &#x3D; [1,4,2,3], B &#x3D; [1,4,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="maximum-binary-tree-2-1.png" alt="img"></td>
<td><img src="maximum-binary-tree-2-2.png" alt="img"></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,2,4,null,1], val &#x3D; 3</span><br><span class="line">Output: [5,2,4,null,1,null,3]</span><br><span class="line">Explanation: A &#x3D; [2,1,5,4], B &#x3D; [2,1,5,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="maximum-binary-tree-3-1.png" alt="img"></td>
<td><img src="maximum-binary-tree-3-2.png" alt="img"></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,2,3,null,1], val &#x3D; 4</span><br><span class="line">Output: [5,2,4,null,1,3]</span><br><span class="line">Explanation: A &#x3D; [2,1,5,3], B &#x3D; [2,1,5,3,4]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先要明确一点, 最大二叉树指的是在构造的时候最大值左边的为左子树, 右边的为右子树</span></span><br><span class="line"><span class="comment">// 因为是放在数组右边的, 所以新节点必然在右子树中</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果比人家右子树中的所有节点都小</span></span><br><span class="line">    <span class="comment">// 只能作为叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// 如果目标值当前节点的值大</span></span><br><span class="line">    <span class="comment">// 说明以当前节点为根的子树要成为我的左子树才行</span></span><br><span class="line">    <span class="comment">// 因为我是放在最右边的, 你在我左边我还比你大</span></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val, root, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 否则, 就要向右边搜索位置</span></span><br><span class="line">    <span class="comment">// 因为你在原来最大值的右边</span></span><br><span class="line">    root-&gt;right = insertIntoMaxTree(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="508-Most-Frequent-Subtree-Sum"><a href="#508-Most-Frequent-Subtree-Sum" class="headerlink" title="508. Most Frequent Subtree Sum"></a><a href="https://leetcode.com/problems/most-frequent-subtree-sum/" target="_blank" rel="noopener">508. Most Frequent Subtree Sum</a></h5><blockquote>
<p>给定一棵树的根，要求你找到最频繁的子树总和。 </p>
<p>节点的子树总和定义为由以该节点为根的子树（包括节点本身）形成的所有节点值的总和。 那么，最频繁的子树总和的值是多少？如果有平局，则以任意顺序返回具有最高频率的所有值。</p>
<p><strong>Examples 1</strong><br>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   -3</span><br></pre></td></tr></table></figure>

<p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p>
<p><strong>Examples 2</strong><br>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   -5</span><br></pre></td></tr></table></figure>

<p>return [2], since 2 happens twice, however -5 only occur once.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想就是先通过递归获得所有子树的和</span></span><br><span class="line"><span class="comment">// 递归的过程中记录下来每一个确定的和出现的次数</span></span><br><span class="line"><span class="comment">// 这需要一个哈希表来记录 sum --&gt; preq 的映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是问题来了, 之后我们要获取出现次数最多的, 也就是值(频率)最大的键</span></span><br><span class="line"><span class="comment">// 并且频率还有可能相同而出现重复</span></span><br><span class="line"><span class="comment">// 第一种方法是 auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);</span></span><br><span class="line"><span class="comment">// 注意, cmp 需要定制 auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)</span></span><br><span class="line"><span class="comment">//                 			&#123; return a.second &lt; b.second; &#125;;</span></span><br><span class="line"><span class="comment">// 这种方法效率有点低, 有多少个重复的 freq, 我们就需要遍历哈希表多少次</span></span><br><span class="line"><span class="comment">// 最坏情况下，时间复杂度为 O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法是再使用一个 multimap 来 [逆映射] 原 unordered_map 中的键值对</span></span><br><span class="line"><span class="comment">// for(auto elem : mapping)</span></span><br><span class="line"><span class="comment">//        mappingSwap.insert(&#123;elem.second, elem.first&#125;);</span></span><br><span class="line"><span class="comment">// 需要注意的是, 使用有序可重复哈希表, 将原来的键变成值, 值变成键</span></span><br><span class="line"><span class="comment">// 然后通过逆迭代器直接获得最大键元素 (在红黑树的最右下边嘛)</span></span><br><span class="line"><span class="comment">// 最坏时间复杂度将为 O(n) 啦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, int&gt; mapping;</span></span><br><span class="line"><span class="comment">//     subTreeSum(root, mapping);</span></span><br><span class="line"><span class="comment">//     auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)</span></span><br><span class="line"><span class="comment">//                 &#123; return a.second &lt; b.second; &#125;;</span></span><br><span class="line"><span class="comment">//     vector&lt;int&gt; res;</span></span><br><span class="line"><span class="comment">//     int preFreq = 0;</span></span><br><span class="line"><span class="comment">//     while(1)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(mapping.empty()) break;</span></span><br><span class="line"><span class="comment">//         auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);</span></span><br><span class="line"><span class="comment">//         if(!res.empty() &amp;&amp; maxFreqSum.second != preFreq)</span></span><br><span class="line"><span class="comment">//             break;</span></span><br><span class="line"><span class="comment">//         preFreq = maxFreqSum.second;</span></span><br><span class="line"><span class="comment">//         res.push_back(maxFreqSum.first);</span></span><br><span class="line"><span class="comment">//         mapping.erase(maxFreqSum.first);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return res;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mappingSwap;</span><br><span class="line">    subTreeSum(root, mapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : mapping)</span><br><span class="line">        mappingSwap.insert(&#123;elem.second, elem.first&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(mappingSwap.empty()) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> preFreq = mappingSwap.rbegin()-&gt;first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mappingSwap.rbegin(); it != mappingSwap.rend(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first != preFreq) <span class="keyword">break</span>;</span><br><span class="line">        res.push_back(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subTreeSum</span><span class="params">(TreeNode* root, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; mapping)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = subTreeSum(root-&gt;left, mapping);</span><br><span class="line">    <span class="keyword">int</span> rightSum = subTreeSum(root-&gt;right, mapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rootSum = leftSum + rightSum + root-&gt;val;</span><br><span class="line">    mapping[rootSum]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rootSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree</a></h5><blockquote>
<p>给定一棵二叉树，找到树中两个给定节点的最低公共祖先（<code>LCA</code>）。一个节点的祖先可以是它自己。</p>
<p><strong>Constraints:</strong></p>
<ol>
<li>所有<code>Node.val</code>互不相同</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code>均存在于给定的二叉树中。</li>
</ol>
<img src="236_LCA_Binary_1.png" alt="img" style="zoom: 33%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来的几道题全是最低公共祖先的问题</span></span><br><span class="line"><span class="comment">// 这题的限制是给定的两个节点都存在树中</span></span><br><span class="line"><span class="comment">// 基本思想就是借助递归, 时刻牢记递归函数的定义, 并且毫不怀疑的使用它</span></span><br><span class="line"><span class="comment">// 这题中, lowestCommonAncestor 函数的定义就是, 接受一个根节点和两个在树中的其它节点</span></span><br><span class="line"><span class="comment">// 返回它们的 LCA</span></span><br><span class="line"><span class="comment">// 所以, 利用后序遍历, 先分别在当前节点的左右子树中找给定两个节点的 LCA</span></span><br><span class="line"><span class="comment">// 根据返回值判断寻找情况</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前节点为空, 肯定找不到 LCA 了</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// left 为左子树中的寻找情况</span></span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="comment">// right 为右子树中的寻找情况</span></span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 注意, 如果当前节点属于这两个节点之一</span></span><br><span class="line">    <span class="comment">// 意味着 当前节点就是它们的最低公共祖先啦</span></span><br><span class="line">    <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 如果在左子树中和右子树中都找到了一个 LCA</span></span><br><span class="line">    <span class="comment">// 同样的, 说明当前节点就是它们的 LCA</span></span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 否则, 返回在 以当前节点为根的子树 中给定节点的 LCA</span></span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II"><a href="#1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II" class="headerlink" title="1644. Lowest Common Ancestor of a Binary Tree II"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/" target="_blank" rel="noopener">1644. Lowest Common Ancestor of a Binary Tree II</a></h5><blockquote>
<p>给定一棵二叉树的根节点<code>root</code>，返回给定节点p和q的最近公共祖先（<code>LCA</code>）节点。如果<code>p</code>或<code>q</code>之一不存在于该二叉树中，返回<code>null</code>。</p>
<p><strong>Constraints:</strong></p>
<ol>
<li>所有<code>Node.val</code>互不相同</li>
<li><code>p != q</code></li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题和 I 题不同之处在于</span></span><br><span class="line"><span class="comment">// 给定的两个节点可能不在树中</span></span><br><span class="line"><span class="comment">// 所以, 这里我们使用两个 flag</span></span><br><span class="line"><span class="comment">// 在后序遍历的同时, 标志给定的两个节点是否在树中</span></span><br><span class="line"><span class="comment">// 其余的逻辑和 I 题一样</span></span><br><span class="line"><span class="keyword">bool</span> pIsInTree = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> qIsInTree = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 辅助递归函数返回 LCA</span></span><br><span class="line">    res = helper(root, p, q);</span><br><span class="line">    <span class="comment">// 如果有任何一个节点不在树中, 返回 null</span></span><br><span class="line">    <span class="keyword">if</span>(!pIsInTree || !qIsInTree) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* left = helper(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = helper(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 将上题中的 if(root == p || root == q) return root; 分开写就行了</span></span><br><span class="line">    <span class="keyword">if</span>(root == p)</span><br><span class="line">    &#123;</span><br><span class="line">        pIsInTree = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root == q)</span><br><span class="line">    &#123;</span><br><span class="line">       qIsInTree = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III"><a href="#1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III" class="headerlink" title="1650. Lowest Common Ancestor of a Binary Tree III"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/" target="_blank" rel="noopener">1650. Lowest Common Ancestor of a Binary Tree III</a></h5><blockquote>
<p>给定一棵二叉树中的两个节点<code>p</code>和<code>q</code>，返回它们的最近公共祖先节点（<code>LCA</code>）。</p>
<p>每个节点都包含其父节点的引用（指针）。<code>Node</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ol>
<li>所有<code>Node.val</code>互不相同</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code>均存在于给定的二叉树中。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题中的树的节点都有指向父亲的指针, 而且还说给定的两个节点还肯定存在</span></span><br><span class="line"><span class="comment">// 那就更简单了, 直接分别从给定的两个节点逐层向上找</span></span><br><span class="line"><span class="comment">// 借助一个哈希集合, 第一个节点向上找的过程中, 经过的每一个父节点都放进一个集合内</span></span><br><span class="line"><span class="comment">// 等第二个节点向上找的时候, 如果遇到已经在哈希集合中的父节点 (首个遇到的)</span></span><br><span class="line"><span class="comment">// 那就说明这个节点就是它们的 LCA 啦</span></span><br><span class="line"><span class="comment">// 和查找链表的交叉点的思路一样</span></span><br><span class="line"><span class="function">Node* <span class="title">lowestCommonAncestor</span><span class="params">(Node* p, Node* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;Node*&gt; setting;</span><br><span class="line">    <span class="comment">// p 先向上, 同样的自己也可以是自己的祖先</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所以自己也得放进集合</span></span><br><span class="line">        setting.insert(p);</span><br><span class="line">        p = p-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经在集合中了, 就是它!</span></span><br><span class="line">        <span class="keyword">if</span>(setting.count(q)) <span class="keyword">return</span> q;</span><br><span class="line">        setting.insert(q);</span><br><span class="line">        q = q-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV"><a href="#1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV" class="headerlink" title="1676. Lowest Common Ancestor of a Binary Tree IV"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/" target="_blank" rel="noopener">1676. Lowest Common Ancestor of a Binary Tree IV</a></h5><blockquote>
<p>给定一棵二叉树的根节点<code>root</code>和<code>TreeNode</code>类对象的数组（列表）<code>nodes</code>，返回<code>nodes</code>中所有节点的最近公共祖先（<code>LCA</code>）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。</p>
<p><strong>Constraints:</strong></p>
<ol>
<li>所有的<code>Node.val</code>都是互不相同的。</li>
<li>所有的<code>nodes[i]</code>都存在于该树中。</li>
<li>所有的<code>nodes[i]</code>都是互不相同的。</li>
</ol>
<p><img src="binarytree.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 4 和 7 的最近公共祖先是 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [7,6,2,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一题, 我笑了</span></span><br><span class="line"><span class="comment">// I 题是找两个节点的 LCA</span></span><br><span class="line"><span class="comment">// 这题找多个节点的, 思路完全一样</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先将 nodes 中的节点们都放进一个哈希集合中</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : nodes)</span><br><span class="line">        setting.insert(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(root, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">unordered_set</span>&lt;TreeNode*&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* left = dfs(root-&gt;left, setting);</span><br><span class="line">    TreeNode* right = dfs(root-&gt;right, setting);</span><br><span class="line">    <span class="comment">// 将 I 题中的 if(root == p || root == q) return root; 换个写法就行了</span></span><br><span class="line">    <span class="keyword">if</span>(setting.count(root)) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a></h5><blockquote>
<p>  给定一个<strong>二叉搜索树</strong>，找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a></h5><blockquote>
<p>给定二叉树，请检查其是否是其自身的镜像（即围绕其中心对称）。</p>
<p><strong>Example:</strong></p>
<img src="symtree1.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右子树同步遍历</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果都为空, 显然对称</span></span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 此时两者必有不为 null 的</span></span><br><span class="line">    <span class="comment">// 就判断是否有为 null 的</span></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 此时两者都不为 null</span></span><br><span class="line">    <span class="comment">// 就判断它们的值是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree"></a><a href="https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/" target="_blank" rel="noopener">1372. Longest ZigZag Path in a Binary Tree</a></h5><blockquote>
<p>给你一棵以<code>root</code>为根的二叉树，二叉树中的交错路径定义如下：</p>
<p>选择二叉树中任意节点和一个方向（左或者右）。<br>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。<br>改变前进方向：左变右或者右变左。<br>重复第二步和第三步，直到你在树中无法继续移动。<br>交错路径的长度定义为：访问过的节点数目 <code>- 1</code>（单个节点的路径长度为<code>0</code>）。</p>
<p>请你返回给定树中最长交错路径的长度。</p>
<table>
<thead>
<tr>
<th align="center">Example 1</th>
<th align="center">Example 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="sample_1_1702.png" alt="img" style="zoom:80%;" /></td>
<td align="center"><img src="sample_2_1702.png" alt="img"  /></td>
</tr>
</tbody></table>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,1,1,null,1,null,null,1,1,null,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right).</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归形式 1</span></span><br><span class="line"><span class="comment">// 0 表示方向向左</span></span><br><span class="line"><span class="comment">// 1 表示方向向右</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    helper(root-&gt;right, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">bool</span> dir, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    res = max(res, depth);</span><br><span class="line">    <span class="keyword">if</span>(dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是从右方向过来的</span></span><br><span class="line">        <span class="comment">// 之后就要转去左方向</span></span><br><span class="line">        helper(node-&gt;left, <span class="number">0</span>, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 同时还可以接着去右方向</span></span><br><span class="line">        <span class="comment">// 只不过深度要重新计算</span></span><br><span class="line">        helper(node-&gt;right, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是从左方向过来的</span></span><br><span class="line">        <span class="comment">// 之后就要转去右方向</span></span><br><span class="line">        helper(node-&gt;right, <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 同时还可以接着去左方向</span></span><br><span class="line">        <span class="comment">// 只不过深度要重新计算</span></span><br><span class="line">        helper(node-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归形式 2</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp_L = <span class="number">1</span> + helper(root-&gt;left, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp_R = <span class="number">1</span> + helper(root-&gt;right, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    res = max(res, tmp_L);</span><br><span class="line">    res = max(res, tmp_R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir ? tmp_L : tmp_R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// helper(root, 1);</span></span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. Binary Search Tree Iterator</a></h5><blockquote>
<p>  实现一个二叉搜索树迭代器类<code>BSTIterator</code>，表示一个按中序遍历二叉搜索树（<code>BST</code>）的迭代器：</p>
<p>  <code>BSTIterator(TreeNode* root)</code>初始化<code>BSTIterator</code>类的一个对象。<code>BST</code>的根节点<code>root</code>会作为构造函数的一部分给出。指针应初始化为一个不存在于<code>BST</code>中的数字，且该数字小于<code>BST</code>中的任何元素。</p>
<p>  <code>bool hasNext()</code>如果向指针右侧遍历存在数字，则返回<code>true</code>；否则返回<code>false</code>。<br>  <code>int next()</code>将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于<code>BST</code>中的数字，所以对<code>next()</code>的首次调用将返回<code>BST</code>中的最小元素。</p>
<p>  你可以假设<code>next()</code>调用总是有效的，也就是说，当调用<code>next()</code>时，<code>BST</code>的中序遍历中至少存在一个下一个数字。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题考察二叉树的中序遍历的迭代实现</span></span><br><span class="line"><span class="comment">// 只不过把循环分摊在每次调用 next 函数里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) : _pointer(root) &#123;&#125;</span><br><span class="line">    <span class="comment">// 这段和是中序遍历的迭代式写法 while(1) 循环体里的代码完全一样</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            _stack.push(_pointer);</span><br><span class="line">            _pointer = _pointer-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _pointer = _stack.top();</span><br><span class="line">        <span class="keyword">int</span> val = _pointer-&gt;val;</span><br><span class="line">        _stack.pop();</span><br><span class="line"></span><br><span class="line">        _pointer = _pointer-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当 _pointer 为空并且 _stack 也为空的情况下</span></span><br><span class="line">        <span class="comment">// 才没有下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> _pointer || !_stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* _pointer;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; _stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog_v0/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/blog_v0/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/blog_v0/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog_v0/S07PSuYxoZ6CPova/" rel="prev" title="leetcode刷题系列之链表">
      <i class="fa fa-chevron-left"></i> leetcode刷题系列之链表
    </a></div>
      <div class="post-nav-item">
    <a href="/blog_v0/63ixVU2ANYIUKUrm/" rel="next" title="面试知识点详细解读之右值与移动语义">
      面试知识点详细解读之右值与移动语义 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#114-Binary-Tree-Preorder-Traversal"><span class="nav-number">1.</span> <span class="nav-text">114. Binary Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal"><span class="nav-number">2.</span> <span class="nav-text">94. Binary Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#145-Binary-Tree-Postorder-Traversal"><span class="nav-number">3.</span> <span class="nav-text">145. Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal"><span class="nav-number">4.</span> <span class="nav-text">102. Binary Tree Level Order Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">104. Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">6.</span> <span class="nav-text">111. Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#112-Path-Sum"><span class="nav-number">7.</span> <span class="nav-text">112. Path Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#113-Path-Sum-II"><span class="nav-number">8.</span> <span class="nav-text">113. Path Sum II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#437-Path-Sum-III"><span class="nav-number">9.</span> <span class="nav-text">437. Path Sum III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#666-Path-Sum-IV"><span class="nav-number">10.</span> <span class="nav-text">666. Path Sum IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#129-Sum-Root-to-Leaf-Numbers"><span class="nav-number">11.</span> <span class="nav-text">129. Sum Root to Leaf Numbers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="nav-number">12.</span> <span class="nav-text">124. Binary Tree Maximum Path Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="nav-number">13.</span> <span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><span class="nav-number">14.</span> <span class="nav-text">106. Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><span class="nav-number">15.</span> <span class="nav-text">889. Construct Binary Tree from Preorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><span class="nav-number">16.</span> <span class="nav-text">1008. Construct Binary Search Tree from Preorder Traversal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode"><span class="nav-number">17.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II - LeetCode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#98-Validate-Binary-Search-Tree"><span class="nav-number">18.</span> <span class="nav-text">98. Validate Binary Search Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1373-Maximum-Sum-BST-in-Binary-Tree"><span class="nav-number">19.</span> <span class="nav-text">1373. Maximum Sum BST in Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#297-Serialize-and-Deserialize-Binary-Tree"><span class="nav-number">20.</span> <span class="nav-text">297. Serialize and Deserialize Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#653-Two-Sum-IV-Input-is-a-BST"><span class="nav-number">21.</span> <span class="nav-text">653. Two Sum IV - Input is a BST</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List"><span class="nav-number">22.</span> <span class="nav-text">114. Flatten Binary Tree to Linked List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><span class="nav-number">23.</span> <span class="nav-text">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#99-Recover-Binary-Search-Tree"><span class="nav-number">24.</span> <span class="nav-text">99. Recover Binary Search Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#687-Longest-Univalue-Path"><span class="nav-number">25.</span> <span class="nav-text">687. Longest Univalue Path</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#654-Maximum-Binary-Tree"><span class="nav-number">26.</span> <span class="nav-text">654. Maximum Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#998-Maximum-Binary-Tree-II"><span class="nav-number">27.</span> <span class="nav-text">998. Maximum Binary Tree II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#508-Most-Frequent-Subtree-Sum"><span class="nav-number">28.</span> <span class="nav-text">508. Most Frequent Subtree Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">29.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II"><span class="nav-number">30.</span> <span class="nav-text">1644. Lowest Common Ancestor of a Binary Tree II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III"><span class="nav-number">31.</span> <span class="nav-text">1650. Lowest Common Ancestor of a Binary Tree III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV"><span class="nav-number">32.</span> <span class="nav-text">1676. Lowest Common Ancestor of a Binary Tree IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">33.</span> <span class="nav-text">235. Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-number">34.</span> <span class="nav-text">101. Symmetric Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree"><span class="nav-number">35.</span> <span class="nav-text">1372. Longest ZigZag Path in a Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#173-Binary-Search-Tree-Iterator"><span class="nav-number">36.</span> <span class="nav-text">173. Binary Search Tree Iterator</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/blog_v0/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog_v0/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog_v0/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog_v0/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog_v0/lib/anime.min.js"></script>
  <script src="/blog_v0/lib/velocity/velocity.min.js"></script>
  <script src="/blog_v0/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog_v0/js/utils.js"></script>

<script src="/blog_v0/js/motion.js"></script>


<script src="/blog_v0/js/schemes/pisces.js"></script>


<script src="/blog_v0/js/next-boot.js"></script>




  




  
<script src="/blog_v0/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/blog_v0/js/src/clicklove.js"></script>